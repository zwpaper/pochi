# Auto Compact
URL: /auto-compact
Reduce context usage by summarizing long conversations‚Äîinline or into a new task
***

title: "Auto Compact"
description: "Reduce context usage by summarizing long conversations‚Äîinline or into a new task"
icon: "ScanText"
----------------

# Auto Compact

Auto Compact helps you keep long conversations efficient by summarizing earlier messages when your token usage grows large. You can either:

* Compact in the current task (inject a compact summary so you can continue seamlessly)
* Start a new task with the summary (spawn a fresh task seeded with a concise recap)

![Auto Compact overview](../assets/images/auto-compact.png)

## When Auto Compact is available

Auto Compact becomes available from the token usage chip in the toolbar when all of the following are true:

* The conversation isn‚Äôt streaming or executing
* The chat isn‚Äôt read-only
* No other compact action is pending
* Total tokens ‚â• 50,000 (min threshold)

If the threshold isn‚Äôt met, you‚Äôll see a tooltip explaining that more tokens are required to compact.

While compacting, the chip shows a spinner with the ‚ÄúCompacting‚Äù label.

![Compacting in progress](../assets/images/auto-compacting.png)

## Two ways to compact

### Option A ‚Äî Compact in current task

Use this to stay in the same task. Pochi will:

1. Generate a concise summary of the conversation up to your latest message
2. Inject a compact block at the top of your last user message
3. Continue the conversation with the condensed context

> Notes: The summary is wrapped into a compact section and prepended to your last message to preserve intent while saving context.

### Option B ‚Äî Start new task with summary

Use this to branch a fresh task based on the current work. Pochi will:

1. Create a summary of the existing conversation
2. Open a new task seeded with the summary and a short handoff message
3. Navigate you to the new task to continue

![Inline compact summary in current task (expandable)](../assets/images/auto-compact-with-new-task-summery.png)

## Technical Details

* Trigger: You choose either ‚ÄúCompact task‚Äù (inline) or ‚ÄúNew task with summary‚Äù.
* Summary prompt: Pochi asks the model to produce a concise recap focused on key topics, decisions, and important context (limited to a few thousand tokens of output).
* Inline compact: The recap is wrapped in a compact block and prepended to your last user message before the next response.
* New task: The recap becomes the first message of a brand-new task, followed by a short instruction letting the agent analyze status and confirm next steps.
* Safety/availability: Buttons are disabled during streaming/execution, or when below the minimum token threshold.

## Tips

* Prefer inline compact when you want continuity within the same task.
* Use ‚Äúnew task with summary‚Äù to cleanly branch, hand over, or checkpoint work.
* You‚Äôll see a ‚ÄúCompacting‚Äù state while the summary is being generated‚Äîthis can take a moment for very long threads.


# Checkpoints
URL: /checkpoint

***

title: Checkpoints
icon: "Route"
-------------

# Checkpoints

Checkpoints automatically save a snapshot of your workspace after key steps in a task. They help you track changes, roll back when needed, and explore different implementations without worrying about breaking your code.

<div align="center">
  ![Checkpoint overview](../assets/images/checkpoint-overview.png)
</div>

## How checkpoints work

Pochi creates a checkpoint after important actions such as file edits or applied fixes. These checkpoints:

* Run alongside your Git workflow without interference
* Preserve the conversation context when restoring (chat and task context remain intact)
* Track file changes using a shadow Git repository (no writes to your real repository)

Example: while developing a feature, the assistant updates multiple files. Each change creates a checkpoint. You can review each modification, and if needed, roll back to any point without impacting your main branch or real Git history.

## Viewing changes and restoring

After each key action, you can:

1. Click Compare to see modified files and diffs
2. Click Restore to open restore options

<div align="center">
  ![Checkpoint compare](../assets/images/checkpoint-compare.png)
</div>

## Restore options

To go back to a previous point:

1. Click Restore next to any step
2. Choose how you want to restore:
   * Restore Workspace and Task (when available): revert both code and task context
   * Restore Task Only (when available): keep code changes, revert task context
   * Restore Workspace Only: revert code while preserving task context (current default)

Note: The current version focuses on ‚ÄúRestore Workspace Only.‚Äù Other options will appear as their capabilities are enabled.

<div align="center">
  ![Checkpoint restore options](../assets/images/checkpoints-restore.png)
</div>

## Under the hood

In VS Code, Pochi implements checkpoints with a shadow Git that stays separate from your real repository:

* Initializes a bare repository under the extension‚Äôs storage directory (scoped per workspace)
* Points the worktree to your workspace, then stages and commits changes into the shadow repo
* Excludes common large/binary/cache/build artifacts (see Exclusions) to keep things fast and stable

This shadow repo is fully independent. Saving or restoring checkpoints does not create commits in your actual Git repository.

## Requirements

* **Git** must be installed (the shadow Git depends on it). If Git isn‚Äôt available, the checkpoint feature can‚Äôt initialize and will be disabled.

## Smart detection and exclusions

Pochi automatically detects and excludes heavy or redundant files to keep checkpoints lean and fast, including:

* Build artifacts and dependency folders
* Media files and large binaries
* Cache, logs, and temporary files
* Environment configuration files
* Files tracked by Git LFS

With this smart filtering, checkpoints focus on core code changes‚Äîmaking diffs clearer and restores faster.


# CLI
URL: /cli
Pochi CLI allows you to run an AI agent directly from the command line.
***

title: CLI
description: Pochi CLI allows you to run an AI agent directly from the command line.
icon: "SquareTerminal"
----------------------

# CLI

Pochi offers a command-line interface (CLI) that allows you to run an AI agent directly from the command line.

## Oneliner Install

<Tabs items={['Curl', 'Homebrew', 'NPM']}>
  <Tab value="Curl">
    ```bash
    curl -fsSL https://getpochi.com/install.sh | bash
    ```

    To install a specific version, pass the version tag as an argument. For example:

    ```bash
    curl -fsSL https://getpochi.com/install.sh | bash -s "pochi-v0.5.5"
    ```
  </Tab>

  <Tab value="Homebrew">
    ```bash
    brew install tabbyml/pochi/pochi
    ```
  </Tab>

  <Tab value="NPM">
    ```bash
    npm install -g @getpochi/cli
    ```
  </Tab>
</Tabs>

## Authentication

The Pochi CLI uses the same authentication credentials as the VS Code extension for Pochi's cloud services. When you sign in through the VS Code extension, the CLI automatically reuses these credentials.

Credentials are stored in `~/.pochi/config.jsonc`. To authenticate:

1. Install and open the [Pochi VS Code extension](https://marketplace.visualstudio.com/items?itemName=TabbyML.pochi)
2. Follow the sign-in prompts in the extension
3. The CLI will automatically use the same credentials

For non-Pochi models, first configure it in your Pochi configuration file (`~/.pochi/config.jsonc`). See [Models documentation](./models.mdx) for details on how to configure custom providers.

Then you can use the model by specifying the provider and model ID separated by a slash:

```bash
pochi --model groq/llama3-8b-8192 -p "What is the time now?"
```

## Usage

You can pass a prompt to run a task:

```bash
pochi -p "What is the time now?"
```

Or pipe input as a prompt:

```bash
echo "What is the time now?" | pochi
```

For detailed usage instructions, run `pochi -h`, below is the output fom version 0.5.3

```
Usage: pochi [options]

Pochi v0.5.5

Prompt:
  -p, --prompt <prompt>   Create a new task with the given prompt. You can also
                          pipe input to use as a prompt, for example: `cat
                          .pochi/workflows/create-pr.md | pochi`. To use a
                          workflow, use /workflow-name, for example: `pochi -p
                          /create-pr`. Workflows can be embedded in larger
                          prompts, for example: `pochi -p "please /create-pr
                          with feat semantic convention"`

Options:
  --max-steps <number>    Maximum number of stepsto run the task. If the task
                          cannot be completed in this number of rounds, the
                          runner will stop. (default: 24)
  --max-retries <number>  Maximum number of retries to run the task in a single
                          step. (default: 3)

Model:
  --model <model>         The model to use for the task. (default:
                          "qwen/qwen3-coder")

Others:
  -V, --version           Print the version string.
  -h, --help              Print this help message.
```

## Debugging

To enable debug logging for the CLI, you can set the `POCHI_LOG` environment variable:

```bash
POCHI_LOG=debug pochi -p "What is the time now?"
```

This will output detailed logs about the CLI's operation, which can be helpful for troubleshooting issues.

For more granular control, you can specify log levels for specific components:

```bash
POCHI_LOG=Pochi=debug,TaskRunner=trace pochi -p "What is the time now?"
```


# Custom Agent
URL: /custom-agent
Learn how to create and use custom agents in Pochi.
***

title: Custom Agent
icon: Bot
description: Learn how to create and use custom agents in Pochi.
----------------------------------------------------------------

# Custom Agents

Pochi allows you to define custom agents to handle specific tasks. These agents can be tailored with their own system prompts and sets of tools, enabling you to create specialized assistants for your workflows.

## Defining a Custom Agent

Custom agents are defined in `.md` files located in either the project's `.pochi/agents/` directory or the system-wide `~/.pochi/agents/` directory.

An agent definition file consists of two parts: a frontmatter section for configuration and a content section for the system prompt.

Here is an example of a custom agent definition:

```markdown
---
description: Description of when this custom agent should be invoked
tools:
  - tool-1
  - tool-2
  - tool-3
---

Your custom agent's system prompt goes here. This can be multiple paragraphs
and should clearly define the custom agent's role, capabilities, and approach
to solving problems.

Include specific instructions, best practices, and any constraints
the custom agent should follow.
```

If the agent is saved as `my-agent.md` and the `name` attribute is omitted, `my-agent` will be used as the agent name.

### Configuration

The frontmatter provides metadata for the custom agent:

* `name` (optional): A unique name for your agent. If omitted, the filename (without the extension) is used as the name.
* `description` (required): A short description of what the agent does. This is used to help Pochi decide when to use your agent.
* `tools` (optional): A list of tools that the agent is allowed to use. This can be a comma-separated string (e.g., `tool-1, tool-2`) or a YAML array. If omitted, the agent inherits all available tools.

### System Prompt

The content of the file after the frontmatter is the system prompt for the agent. This prompt should define the agent's role, capabilities, and how it should behave.

## Using a Custom Agent

You can mention the custom agent's name in your prompt, and Pochi may decide to use it based on the context.

## Managing Custom Agents

You can manage your custom agents through the Pochi interface or by directly manipulating the agent definition files. The common operations include:

* **List**: View all available agents in the `.pochi/agents/` directory or in Pochi settings.
* **Create**: Create a new `.md` file in the `.pochi/agents/` directory.
* **Delete**: Remove the corresponding agent file.
* **Edit**: Modify the agent's definition file.


# GitHub
URL: /github

***

title: GitHub
icon: "Github"
--------------

# GitHub

Use Pochi's AI assistant directly in your GitHub repository by commenting on pull requests to perform code reviews, explain changes, and suggest improvements.

<Callout type="info" title="How it works">
  This integration runs inside a GitHub Actions runner. It temporarily installs
  the pochi CLI and executes tasks in the context of your repository. Progress
  is continuously updated under the triggering comment, and a final result
  (‚úÖ/‚ùå) is posted when finished.
</Callout>

## Getting Your API Keys

1. Log in to your Pochi account and go to **API Keys** from your user menu

![User button overview](../assets/images/api-overview.png)

2. Create a new API key with a descriptive name
3. Copy the generated key (it's only shown once)

![API page interface](../assets/images/api-page-interface.png)

4. Add it to your GitHub repository as a secret named `POCHI_API_KEY`. See [GitHub's official guide](https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets) for detailed steps:
   * Go to **Settings** ‚Üí **Secrets and variables** ‚Üí **Actions**
   * Click **"New repository secret"**
   * Name: `POCHI_API_KEY`, Value: your API key

## Setup

Create a workflow file `.github/workflows/pochi.yml` in your repository:

```yaml
name: pochi

on:
  issue_comment:
    types: [created]

jobs:
  pochi:
    if: startsWith(github.event.comment.body, '/pochi')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run pochi
        uses: tabbyml/pochi/packages/github-action@main
        env:
          # Required: Pochi session token (get it from app.getpochi.com and add as a repository secret)
          POCHI_API_KEY: ${{ secrets.POCHI_API_KEY }}
          # Optional: custom model (defaults to CLI's default model if not set)
          # See the Models page for model options and configuration
          # POCHI_MODEL: google/gemini-2.5-pro
```

Notes:

* Triggered by `issue_comment` (created) and runs only if the comment body starts with `/pochi`
* Requires write permissions to read changes, post comments, and add reactions to PRs
* Provide `POCHI_API_KEY` via env; optionally set `POCHI_MODEL` to customize the model
* By default, the action uses GitHub's built-in `GITHUB_TOKEN` (github-actions bot). You can customize this by setting a custom `GITHUB_TOKEN` environment variable with your own Personal Access Token (PAT)

## Usage

Comment on a PR with `/pochi` followed by your request, e.g. `/pochi review this code`, `/pochi explain the changes in this PR`, `/pochi suggest improvements`.

![Comment example](../assets/images/github-comment.png)

Once triggered:

* Pochi reacts to your comment with üëÄ to indicate it's running
* A progress comment is updated every 15 seconds
* When finished, it posts the final result and reacts with üöÄ (success) or ‚àí1 (failure)

![Progress example](../assets/images/github-progress.png)

![Actions run example](../assets/images/github-action-run.png)

Permission requirement: Only users with write/admin permission can trigger execution. Otherwise, an error will be posted as a comment.

## Advanced configuration

### Use a custom GitHub token (optional)

By default, the action uses the GitHub-provided `GITHUB_TOKEN`. For cross-repo or higher-privileged operations, you can override it with a PAT:

```yaml
- name: Run pochi
  uses: tabbyml/pochi/packages/github-action@main
  env:
    GITHUB_TOKEN: ${{ secrets.CUSTOM_GITHUB_TOKEN }} # Your PAT
    POCHI_API_KEY: ${{ secrets.POCHI_API_KEY }}
```

### Permissions

Ensure the workflow includes these permissions:

```yaml
permissions:
  contents: write # Read repo contents and commit changes if needed
  issues: write # Comment on issues/PRs
  pull-requests: write # Access PR information and status
```


# Getting Started
URL: /
Welcome to Pochi - Full-Stack AI Teammate Guide
***

title: "Getting Started"
description: "Welcome to Pochi - Full-Stack AI Teammate Guide"
icon: "Album"
-------------

# Getting Started

[Pochi](https://getpochi.com) is an open-source AI coding agent built as a VS Code extension, checkout the video below to see it in action.

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1CDxAcO9WGFFC45x5a5HDFdT4u6rtdJrB/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Pochi Demo - End-to-End Experience"
  />
</div>

## Installation

Install the Pochi extension from the [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=TabbyML.pochi) or [OpenVSX](https://open-vsx.org/extension/TabbyML/pochi).

We recommend dragging Pochi to the right side of your VSCode window to get the best experience.

![Drag to right sidebar](../assets/images/vscode-right-sidebar.png)

With Pochi, you can use any LLM provider by configuring their API keys. Use the VS Code command `Pochi: Open Custom Model Settings` to open the settings file and [configure it](./models). Alternatively, Pochi offers cloud-based services. Creating a Pochi account gives you access to:

* Pochi's managed LLM models
* Shared task histories and team management
* Integrations with GitHub and Slack for a collaborative workflow

To use these features, sign up at [app.getpochi.com](http://app.getpochi.com) and log in to your VS Code extension.

## Customize

Pochi supports hierarchical configuration with both global (user-level) and workspace-specific settings.

1. **Global Configuration**: `~/.pochi/config.jsonc` - Your default configuration available across all projects
2. **Workspace Configuration**: `.pochi/config.jsonc` - Project-specific configuration that override or extend global settings

You can tailor Pochi to your needs by editing these configuration file. The file uses the JSONC (JSON with Comments) format, so you can add notes to explain your settings.

```jsonc
{
  // The schema enables autocompletion and validation in your code editor.
  "$schema": "https://getpochi.com/config.schema.json",

  // For details on available options, see the "Models," "Rules," pages in the sidebar
  // ...
}
```


# MCP
URL: /mcp
Model Context Protocol integration and configuration
***

title: MCP
description: Model Context Protocol integration and configuration
icon: "Spline"
--------------

# MCP (Model Context Protocol)

The **Model Context Protocol (MCP)** revolutionizes how Pochi interacts with external services, databases, and APIs. Think of MCP as a universal adapter that connects Pochi to virtually any data source or tool, dramatically expanding what your AI assistant can accomplish.

## Configure

Use the VSCode command `Pochi: Open MCP Server Settings` to open the settings.

```json
{
  "mcp": {
    "context7": {
      "command": "npx",
      "args": ["@upstash/context7-mcp"]
    }
  }
}
```

After saving the configuration, you will see the MCP server appear in the **Tools** section of Pochi's settings page.

![MCP Server Context7](../assets/images/mcp-context7.png)

You can use the toggle switch to enable or disable the MCP server entirely. You can also click on the tool badge to toggle individual tools within the MCP server.

## Examples

### Local MCP Servers (Stdio Transport)

```json
{
  "filesystem": {
    "command": "npx",
    "args": [
      "-y",
      "@modelcontextprotocol/server-filesystem",
      "/path/to/allowed/files"
    ],
    "env": {
      "HOME": "/Users/yourname"
    }
  }
}
```

### Remote MCP Servers (HTTP Transport)

#### Custom API Server

```json
{
  "my-api": {
    "url": "https://api.mycompany.com/mcp",
    "headers": {
      "Authorization": "Bearer your-api-token",
      "X-API-Version": "v1"
    }
  }
}
```

#### SSE (Server-Sent Events) Server

```json
{
  "realtime-data": {
    "url": "https://data.example.com/mcp/sse",
    "headers": {
      "Authorization": "Bearer your-token"
    }
  }
}
```

## Configuration Hierarchy

Pochi supports hierarchical MCP configuration with both global (user-level) and workspace-specific settings.

1. **Global Configuration**: `~/.pochi/config.jsonc` - Your default MCP servers available across all projects
2. **Workspace Configuration**: `.pochi/config.jsonc` - Project-specific MCP servers that override or extend global settings

The workspace configuration takes precedence and is merged with the global configuration, allowing you to:

* Add project-specific MCP servers
* Override global server configurations for specific projects
* Maintain different MCP setups for different codebases

### Global MCP Configuration Example (`~/.pochi/config.jsonc`)

```json
{
  "mcp": {
    "context7": {
      "command": "npx",
      "args": ["@upstash/context7-mcp"]
    },
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "/Users/yourname/Documents"
      ]
    }
  }
}
```

### Workspace MCP Configuration Example (`.pochi/config.jsonc`)

```json
{
  "mcp": {
    "project-db": {
      "command": "npx",
      "args": ["@modelcontextprotocol/server-sqlite", "./database.db"]
    },
    "filesystem": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "./src"
      ]
    }
  }
}
```

In this example:

* The `context7` server from global config will be available
* The workspace-specific `project-db` server will be added
* The `filesystem` server configuration will be overridden to only access the project's `src` directory


# Models
URL: /models
Manage Pochi's model settings
***

title: Models
description: Manage Pochi's model settings
icon: "Zap"
-----------

# Models

Pochi leverages the AI SDK to support various LLM providers and can run local models.

## Pochi

After signing in, you gain access to the Pochi models shown below. Pochi uses a usage-based pricing strategy with no additional charges. For detailed pricing information, visit [https://app.getpochi.com/pricing](https://app.getpochi.com/pricing).

![Pochi Models](../assets/images/pochi-models.png)

## OpenAI Compatible

Pochi allows you to configure any LLM provider that offers an OpenAI-compatible API by setting up the appropriate API keys. To configure custom models, use the VS Code command `Pochi: Open Custom Model Settings` to open the settings configuration file.

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "provider-id": {
      "apiKey": "your_api_key",
      "baseURL": "https://api.provider.com/v1",
      "models": {
        "model-id": {
          // The contextWindow and maxTokens are optional right now, it's default set to 10k and 4096
          // "contextWindow": 131072,
          // "maxTokens": 8000
        }
      }
    }
  }
}
```

### Chutes

Chutes provides access to various AI models through their API. To use Chutes, you'll need to obtain an API token from [Chutes Platform](https://chutes.ai/).

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "chutes": {
      "apiKey": "your_api_token",
      "baseURL": "https://llm.chutes.ai/v1",
      "models": {
        "zai-org/GLM-4.5-FP8": {
          "name": "glm-4.5"
        }
      }
    }
  }
}
```

### Cerebras

Cerebras provides AI models through their OpenAI-compatible API. To use Cerebras, you'll need to obtain an API key from [Cerebras Platform](https://inference.cerebras.ai/).

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "cerebras": {
      "apiKey": "your_api_key",
      "baseURL": "https://api.cerebras.ai/v1",
      "models": {
        "llama3.1-8b": {
          "name": "llama-3.1-8b"
        }
      }
    }
  }
}
```

### DeepInfra

DeepInfra provides access to a wide range of AI models through their OpenAI-compatible API. To use DeepInfra, you'll need to obtain an API token from [DeepInfra Platform](https://deepinfra.com/).

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "deepinfra": {
      "apiKey": "your_api_token",
      "baseURL": "https://api.deepinfra.com/v1/openai",
      "models": {
        "meta-llama/Llama-3.3-70B-Instruct": {
          "name": "llama-3.3-70b"
        }
      }
    }
  }
}
```

### Groq

Groq is a cloud-based AI platform that provides fast inference for large language models.

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "groq": {
      "apiKey": "your_api_key",
      "baseURL": "https://api.groq.com/openai/v1",
      "models": {
        "llama3-8b-8192": {
          "name": "llama-3-8b"
        }
      }
    }
  }
}
```

### LM Studio

LM Studio is a local IDE application that allows you to run and experiment with language models on your own machine.

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "lmstudio": {
      "baseURL": "http://127.0.0.1:1234/v1",
      "models": {
        "gemma-2b-it-q4f32_1": {
          "name": "gemma-2b"
        }
      }
    }
  }
}
```

### Mistral

Mistral AI provides a range of powerful language models available through their API. To use Mistral models, you'll need to obtain an API key from [Mistral AI Platform](https://console.mistral.ai/).

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "mistral": {
      "apiKey": "your_api_key",
      "baseURL": "https://api.mistral.ai/v1",
      "models": {
        "mistral-small-latest": {
          "name": "mistral-small"
        }
      }
    }
  }
}
```

### Ollama

Ollama is a tool that allows you to run large language models locally on your machine with a simple API.

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "ollama": {
      "baseURL": "http://localhost:11434/v1",
      "models": {
        "llama3:8b": {
          "name": "llama-3-8b"
        }
      }
    }
  }
}
```


# Parallel Agents
URL: /parallel-agents
Run multiple AI agents concurrently to accelerate development and tackle complex tasks.
***

title: "Parallel Agents"
description: "Run multiple AI agents concurrently to accelerate development and tackle complex tasks."
icon: "GitMerge"
----------------

# Parallel Agents

Most coding assistants can handle one task at a time. But real projects often need multiple agents exploring, refactoring, and developing different features in parallel - across different branches or experiments.
That's why we built **Parallel Agents**.

**Parallel Agents** let you run multiple Pochi agents concurrently, each inside its own Git worktree - isolated but synchronized with the same repository.
Each agent can explore the code base, develop different PRs, or test different ideas in parallel without interfering with each other, while you can check their works and manage them in Pochi extensions.

Pochi Parallel Agents has the following features:

* **Worktree Integration:** Leverage the Git worktree feature to gain an isolated env, did not recreate the wheel again.
* **Multi-to-Multi Execution:**  Tasks from Pochi could run in different worktree or the same one.
* **Task Management:** All tasks can be managed on the Pochi sidebar.
* **Integrated UX:** Review agents' works and open the terminal from one click.
* **VSCode Native:** Create new Agents directly from the Repository manage view from VSCode.

## Demo and Real World Use Cases

Let's go through the features of **Parallel Agents** by showing the real world workflow while we are developing Pochi.
For the following demo, we will work on those two issues:

1. [https://github.com/TabbyML/pochi/issues/619](https://github.com/TabbyML/pochi/issues/619)
2. [https://github.com/TabbyML/pochi/issues/654](https://github.com/TabbyML/pochi/issues/654)

Meanwhile, we'll explore together how worktree feature is implemented.

We could operate on the default worktree directly; however, since those two issues are independent, we prefer to create a separate worktree for each.

### Creating Worktree

There are two ways to create a new Worktree,

1. Create from Pochi sidebar directly

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1HgO1JdMswvFOKhSwRQCU3pFOIv2lKRbB/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Create Pochi Tasks"
  />
</div>

2. Create from VSCode Repository management
   You can first create a new worktree in VSCode Source Control Panel. Then manually link this worktree to a branch, and open this worktree in Pochi.

<div align="center">
  ![Create Worktree](../assets/images/create-worktree.png)
</div>

<div align="center">
  ![Open Worktree in Pochi](../assets/images/worktree-pochi.png)
</div>

In both cases, Pochi will create and check out the branch at the specified disk path as a worktree. You can then perform any action as if it were a standard Git repository, as an independent dev environment in each worktree.

### Create Task in Pochi

Now we are ready to initiate tasks in each worktree to let them run in parallel. You'd see that once a task is initiated, Pochi opens a new tab for each task, and you can switch between different tabs to monitor the progress of each task.

<div align="center">
  ![Parallel Tasks](../assets/images/parallel-tasks.png)
</div>

### Interaction with Tasks

When you click on the task, Pochi will open the specific task, allowing you to interact with it.

<div align="center">
  ![Interact with Tasks](../assets/images/task-interaction.png)
</div>

For instance, the task `fix-issue-654` is now complete. We can review the modifications by selecting `Diff worktree with origin/main`, and Pochi will open a tab showing all the files changes.

Or choose `Open in Integrated Terminal` to launch the terminal within this worktree for command execution.


# Permissions
URL: /permissions
Manage Pochi's auto-approval settings
***

title: Permissions
description: Manage Pochi's auto-approval settings
icon: "Shield"
--------------

# Permissions

By default, all permissions in Pochi are enabled. You can customize these permissions at any time using the Auto-Approve settings.

<div align="center">
  ![Auto Approve](../assets/images/auto-approve.png)
</div>

* **Read**: Read the file content Pochi decides to look up for analyzing or completing tasks.
* **Write**: Creates new files, edits existing code, generates boilerplate, and writes documentation.
* **Execute**: Manages dependencies, runs builds, tests, and perform system operations.
* **Use MCP**: Interacts with databases, APIs, and other external services to expand its capabilities with MCP server.
* **Retry**: Automatically retries failed commands, code changes, and installations.


# Queued Messages
URL: /queued-messages
Add tasks to a queue while Pochi is busy, ensuring a non-blocking experience.
***

title: Queued Messages
description: Add tasks to a queue while Pochi is busy, ensuring a non-blocking experience.
icon: "Layers"
--------------

# Queued Messages

The Queued Messages feature allows you to add multiple messages to a queue, which are then combined into a single prompt for execution. This lets you build up a complex request in pieces, which is especially useful while Pochi is busy.

<div align="center">
  ![Queued Messages UI](../assets/images/queued-messages.png)
</div>

When Pochi is busy, you don't have to wait to give it your next instruction. Here‚Äôs what happens:

1. **Queue with a Shortcut**: Type your prompt and press `Cmd+Enter` (`Ctrl+Enter` on Windows/Linux). Your message will be added directly to the queue.
2. **See What's in Line**: The "Queued Messages" panel appears, showing you a list of all the tasks waiting to be executed.
3. **Combined for Execution**: Once Pochi is ready, it will take all the messages from the queue, merge them into a single prompt, and then execute it.
4. **Remove with a Click**: If you decide you don't need a task done anymore, just click the `X` next to it to remove it from the queue.


# Rules
URL: /rules
Define coding standards and development guidelines
***

title: Rules
description: Define coding standards and development guidelines
icon: "Ruler"
-------------

# Rules

You can provide custom instructions to Pochi by creating an `README.pochi.md` file. This is similar to CLAUDE.md or Cursor‚Äôs rules.

<Callout title="AGENTS.md support">
  Pochi also supports [AGENTS.md](https://agents.md) as an alternative to `README.pochi.md`. Both files serve the same purpose and are treated identically by Pochi.
</Callout>

### Example

Below example is the `README.pochi.md` file for Pochi itself.

```markdown
Pochi is an project developed using following technologies:
1. always use kebab-case for filenames.
2. always use camelCase for variables, functions.
3. use PascalCase for classes, interfaces, types.

# Testing for non packages/vscode
We use vitest framework.
our test use vitest framework.
test command: `bun run test`
coverage test command: `bun run test -- --coverage`

## Testing for packages/vscode
We use mocha framework, when creating test, do not use mocks for filesystem, just use vscode.workspace.fs to create files and folders, and only use mocha primitives for testing. use sinon for mocks.

(assuming cwd is packages/vscode)
test command: `bun run test`
coverage test command: `bun run test:coverage`

When encountering issues like `TypeError: Descriptor for property readFile is non-configurable and non-writable`, please use `proxyquire` to mock the module.

# Misc
1. use `bun check` to format / linting the code, use `bun fix` to automatically apply the fix.
2. use `bun tsc` to check the types.
3. For packages/code it uses `ink` for react terminal ui.
4. Prefer `@/lib` over `../lib` for imports.
5. For global variable in typescript, prefer using PascalCase, e.g `GlobalVariableName`, instead of `GLOBAL_VARIABLE_NAME`.
6. For biome related warning / errors, prefer using `bun fix` in the root directory to fix the issues.
```

## Locations

Pochi looks for rules in two locations:

### Workspace

Pochi first checks for a `README.pochi.md` (or `AGENTS.md`) file in your current workspace root directory. This is where you define project-specific rules that apply only to your current project.

### Global

Pochi also reads global rules defined in `~/.pochi/README.pochi.md`. These rules apply to all projects and are suitable for any personal rules that Pochi should follow.

You can view current active rules in toolbar's token usage popover

<div align="center">
  ![Token Usage](../assets/images/usage-token-popover.png)
</div>


# Share
URL: /share
Share your development context with team members
***

title: Share
description: Share your development context with team members
icon: "Share2"
--------------

# Share

The **Share** feature in Pochi's toolbar allows you to share your current development context with others.

<Callout type="info" title="Public Access">
  Shared conversations are publicly accessible to anyone with the link. Do not share sensitive information or private code.
</Callout>

<div align="center">
  ![Task Sharing](../assets/images/task-sharing.png)
</div>

### How it works

When you share a conversation, Pochi:

1. Persist your task to our servers, and create a unique public URL for the task..
2. Makes task accessible via a link - `app.getpochi.com/share/<shareId>`


# Slack
URL: /slack
Pochi's integration with Slack
***

title: Slack
description: Pochi's integration with Slack
icon: "Slack"
-------------

# Slack

Pochi's Slack integration allows you to use Pochi directly within your Slack workspace, bringing AI-powered development assistance to your team conversations.
Start tasks in Slack and seamlessly switch to the Cloud IDE when you need the full development experience.

<Callout type="info" title="Cloud IDE">
  When you send messages to Pochi in Slack, tasks are executed in remote environment running in the cloud. You can switch to the Cloud IDE to continue working on the task.
</Callout>

## Getting Started

### Adding Pochi to Your Workspace

1. **Install the Integration**: Add Pochi to your Slack workspace through the `Add to Slack` button on the [homepage](https://app.getpochi.com/home)
   ![Slack Installation](../assets/images/slack-install-home.png)
2. **Authorize Access**: Grant the necessary permissions for Pochi to interact with your Slack channels
   ![Slack Authorization](../assets/images/slack-authorize.png)
3. **Start Collaborating**: Begin using Pochi in any channel or direct message where it's been added. If using channels, please make sure to invite Pochi to the channel before creating a task.

### Basic Usage

Once Pochi is added to your workspace:

1. \[Optional] **Invite Pochi to Channels**: If you want to interact with Pochi in channels, simply send `@Pochi` in the channel, and you will be prompted to invite Pochi to the channel.
2. \[Optional] **Default Github Repository**: Set the repository in the Channel Topic, so Pochi knows which repository to work on by default.
   * Format: `[repo:OWNER/REPO]`, for example, `[repo:TabbyML/pochi]`
3. **Start Task**: Send a task prompt to Pochi in Direct Messages or channels using the following format:
   * If a default repository is set: `/newtask PROMPT`, for example, `/newtask What are recent commits`
   * If no default repository is set or you want to run Pochi with another repository : `/newtask [OWNER/REPO] PROMPT`, for example, `/newtask [TabbyML/tabby] What are recent commits`
4. **Real-time Updates**: Watch as Pochi executes tasks and provides updates directly in Slack.
5. **Follow-up**: After the task is completed, Pochi might ask some follow-up questions, or you can provide responses clicking the option buttons or the Reply button.

![Slack Task](../assets/images/slack-task.png)

### Continue in Cloud IDE

When you need the full IDE experience:

1. **Access Task Page**: Click on the `See Details` button to navigate to the task in Pochi's web interface.
2. **Click Remote Icon**: Look for the remote/external link icon in the task interface.
   ![Slack Remote Button](../assets/images/slack-remote-button.png)
3. **Continue Development**: Pick up exactly where you left off.
   ![Slack VSCode Web](../assets/images/slack-vscode-web.png)

## Frequently Asked Questions

### Why do I get a `not_in_channel` error when creating a task in a channel?

Verify that Pochi has been properly added to the channel. If Pochi is not invited to the channel, mention @Pochi in the channel to invite it.

### Why can't I access the Cloud IDE?

Only the Task Owner has permission to access the Cloud IDE. Make sure you are the Task Owner and logged in to Pochi with the same account in your browser.


# Tab Completion
URL: /tab-completion
Inline code completion
***

title: Tab Completion
description: Inline code completion
icon: "Code"
------------

# Tab Completion

**Tab Completion** is Pochi's in-editor inline code completion feature that provides AI-powered suggestions as you type, helping you write code faster and more efficiently.

Pochi uses a state-of-the-art model that adapts to your coding patterns in real time,
drawing on recent edits, diagnostics, and surrounding context to generate helpful,
relevant completions right in your editor.

The suggestion can be rendered as a diff preview, showing exactly what changes will be made to your code.

<div align="center">
  ![Tab Completion showing suggestion via diff](../assets/images/tab-completion-diff.png)
</div>

Alternatively, suggestions can appear as ghost text inline with your code.

<div align="center">
  ![Tab Completion showing suggestion via ghost text](../assets/images/tab-completion-ghost-text.png)
</div>

### Multi-Language Support

Works across popular programming languages including:

* JavaScript/TypeScript
* Python
* Java
* C/C++
* Go
* Rust
* And many more

## Using Tab Completion

Just start typing. Pochi will surface suggestions automatically. The more you use it, the more it understands your codebase, thus suggesting better edits.

### Keyboard Shortcuts

| Key       | Action                                      |
| --------- | ------------------------------------------- |
| `Tab`     | Accept the current suggestion               |
| `Escape`  | Dismiss the suggestion                      |
| `Alt + ]` | Next suggestion (if multiple available)     |
| `Alt + [` | Previous suggestion (if multiple available) |

## Status Bar Item

The status bar item shows the status of Pochi Tab Completion. It indicates whether the feature is enabled, disabled, or if any errors have occurred.

### Disable/Enable

You can click the status bar item to toggle Pochi Tab Completion on and off.

### Feature Conflicts

Pochi's Tab Completion feature may conflict with other extensions that provide code completions, such as GitHub Copilot. If you encounter issues, you can disable conflicting features to use Pochi Tab Completion.

<div align="center">
  ![Resolve Conflicts](../assets/images/tab-completion-resolve-conflicts.png)
</div>

## Tab Completion Model

Pochi uses its own hosted, state-of-the-art tab completion model optimized for speed and accuracy.

We are actively working on allowing you to customize Tab Completion providers in VS Code settings. In future versions, you'll be able to use different models, including those running on your local machine.

***

**Need help?** Join our [Discord](http://getpochi.com/discord) for assistance with Tab Completion features.


# Troubleshooting
URL: /troubleshooting
Common issues and how to resolve them
***

title: "Troubleshooting"
icon: "CircleQuestionMark"
description: "Common issues and how to resolve them"
----------------------------------------------------

# Troubleshooting

To debug any issues with Pochi, you can check the logs from webview console or vscode output console.

### Webview Console

1. Open `Developer: Use Webview Developer Tools` command in VSCode
2. Go to the Console tab
3. Look for error messages related to Pochi

You can configure the log level in VSCode Settings with following snippet

```json
{
  "pochi.advanced": {
      "webviewLogLevel": "DEBUG" // Set to "DEBUG" to see more detailed logs
  },
}
```

### VSCode Output Console

1. Use `Output: Show Output Channels` command in VSCode
2. Select "Pochi" from the dropdown
3. Look for error messages or warnings

# Getting help

If you‚Äôre experiencing issues with Pochi:

1. Report issues on Github

   The best way to report bugs or request features is through our GitHub repository: [https://github.com/TabbyML/pochi/issues](https://github.com/TabbyML/pochi/issues)

2. Join our Discord

   For real-time help and community discussion, join our Discord server: [https://getpochi.com/discord](https://getpochi.com/discord)


# VS Code
URL: /vscode

***

title: VS Code
icon: "LayoutPanelLeft"
-----------------------

# VS Code

This page covers the core Pochi experience in VS Code, from installation and setup to the main chat and task management features.

## Installation

Install the Pochi extension from the [VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=TabbyML.pochi) or [OpenVSX](https://open-vsx.org/extension/TabbyML/pochi).

For the best experience, we recommend dragging the Pochi view to the right sidebar to use it side-by-side with your editor.

![Drag the Pochi view to the right sidebar for a side-by-side experience.](../assets/images/vscode-right-sidebar.png)

## Welcome

Upon first launch, Pochi's Welcome page offers two ways to get started:

* **Sign in to Pochi:** Click "Sign In" and authorize in your browser to use Pochi subscriptions, models, and cloud features.
* **Bring Your Own Key (BYOK):** Use your own models by running `Pochi: Open Custom Model Settings` from the Command Palette. This opens `~/.pochi/config.jsonc` for you to add API keys. See [Models](/models) for details.

<div align="center">![The Welcome page provides options to sign in or configure your own models.](../assets/images/welcome-page.png)</div>

## Chat

Access the Pochi chat panel via the Activity Bar icon or shortcut (macOS: `Cmd+L`, Win/Linux: `Ctrl+L`). This is your main interface for interacting with Pochi. **Note:** An active workspace (i.e., an open folder) is required to use the chat.

The panel's title bar includes actions for starting a new task and viewing all tasks.

<div align="center">![The main Chat panel is where you interact with Pochi.](../assets/images/chat-page.png)</div>

## Prompting

The input box, located below the chat history, is where you'll compose your messages and control the chat.

* **Auto-Approve Menu:** This menu at the top of the zone allows you to grant Pochi permission to use tools autonomously, streamlining the workflow.
* **Todo List:** When Pochi creates a to-do list for a task, it will appear here, allowing you to track progress.
* **Chat Input:** The main text area supports both text and image uploads. You can attach files by clicking the **paperclip icon** or by dragging and dropping them into the input area.
* **Bottom Toolbar:** The toolbar at the very bottom provides several key functions:
  * **Model Selector:** Choose which language model you want to interact with.
  * **Token Usage & Compact Task:** Monitor the token count of your conversation. If the conversation becomes long, a **Compact Task** button will appear, allowing you to condense the history and save tokens.
  * **Sharing:** Share your chat session with others (requires a Pochi account).
  * **Submit/Stop Button:** The send button dynamically transforms into a stop button during message generation, allowing you to interrupt the AI at any time.

<div align="center">
  ![The Prompt Zone provides access to key features like model selection and auto-approval.](../assets/images/home-page-toolbox.png)
</div>

## Tasks

A chat session in Pochi is saved as a **Task**. You can view your entire task history from the task list page.

Some AI-powered actions might generate a **Sub-task**, which is a new, focused chat session dedicated to a specific part of the original task.
When you're in a sub-task, you'll see a "Back" button to navigate to the parent task, allowing you to maintain context while breaking down complex problems.
By default sub-tasks are hidden in the task list.

By default, task history is stored locally. Signing in to a Pochi account enables cloud storage for your tasks, along with sharing and team collaboration features.
Be aware that clearing VS Code's extension data may erase your local task history.

<div align="center">![The Task List page shows your historical task sessions.](../assets/images/task-page.png)</div>

## Troubleshooting

Having issues? Here are a few things to check:

* **No Active Workspace:** Pochi requires an open folder to function correctly. Make sure you have a workspace open.
* **Sign-in/Model Configuration:** Verify that you are either signed in to your Pochi account or have a valid API key configured in your `~/.pochi/config.jsonc`.

For more help, check the full [Troubleshooting](/troubleshooting) page or join our community on [Discord](https://getpochi.com/discord).


# Workflows
URL: /workflows
Automate common development sequences
***

title: Workflows
description: Automate common development sequences
icon: "Workflow"
----------------

# Workflows

Workflows are step-by-step automation templates that guide Pochi through complex, multi-step processes. Think of them as detailed recipes that Pochi can follow to complete common development tasks consistently and efficiently.

### Configure

Workflows shall be put inside `.pochi/workflows/` directory in your workspace root. Each workflow is a markdown file with a specific name. You can also specify metadata, such as which model to use for the workflow, through YAML frontmatter.

Pochi also supports global workflows, which will be loaded from `~/.pochi/workflows`. This allows you to define a set of common workflows that you use across all of your projects, without having to copy them into each project's workspace.

`.pochi/workflows/create-pr.md` is an example we used in Pochi's own development.

```markdown
---
model: "anthropic/claude-4-sonnet"
---

Please help create a PR for the current staging changes, following these guidelines:
- If there are no staging changes but there are uncommitted changes, please stage them first.
- Create a branch name based on the current git diff status.
- Write a meaningful commit message/PR title.
- Use the gh CLI to create a PR.
- When running the push operation, it might be aborted due to a husky pre-push hook. For formatting issues, amend the files and try again. For other issues, try to resolve them as much as possible.
- The base branch for the PR should always be `main`.
- Always push the branch to the remote repository before creating the PR.

When creating PR with markdown description, pay attention to escape backticks, otherwise it will be executed as command substitution in the shell.
```

### Usage

Once your workflows are set up, using them is straightforward:

1. **Type `/` in VS Code** to trigger the Pochi workflow selector
2. **Select a workflow** from the dropdown menu and press `Enter`.
3. You can attached additional context when running the workflow, e.g `/create-pr assign Meng for review after creation`.

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1p9UeAfkLEOlXBABF4CGub_aqAlAnmbVe/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Pochi Demo - Workflows"
  />
</div>

*This video demonstrates how to use workflows in VS Code*


# Weekly Update
URL: /developer-updates/2025-08-29-weekly-update-1

***

## title: Weekly Update #1

# Weekly Update #1

### TL;DR

This week we polished the VS Code extension with some **UX upgrades**, open-sourced the **Pochi CLI**, and did a few rounds of **codebase cleanup** to make contributing easier and friendlier for newcomers. We look forward to your first visit to the repo!

### Enhancements ‚ú®

* **Drag & drop images:** Share visuals with Pochi in the VS Code chat just by dragging them in. [#64](https://github.com/TabbyML/pochi/pull/64)
* **Improved docs:** Updated structure and added guidance on model settings for easier use. [#60](https://github.com/TabbyML/pochi/pull/60), [#63](https://github.com/TabbyML/pochi/pull/63) , [900d162](https://github.com/TabbyML/pochi/commit/900d1629c4e97833e24a4450c438a585dca583d4)
* **Model pricing at your fingertips:** Check model costs directly in settings before choosing one. [#74](https://github.com/TabbyML/pochi/pull/74)

### Bug Fixes üêõ

* **File search now correctly surfaces matching files:** Queries that used to return empty results will now behave as expected. [#79](https://github.com/TabbyML/pochi/pull/79)


# Weekly Update
URL: /developer-updates/2025-09-05-weekly-update-2

***

## title: Weekly Update #2

# Weekly Update #2

### TL;DR

We had a massive week ‚Äî **62 PRs shipped** üéâ!

Pochi can now reply to you right in **GitHub comments & issues**, the interface speaks more languages with new **i18n support**, and we rolled out a sleeker, more powerful **background job system**. On top of that, the **CLI** got smarter, **autocomplete** got friendlier, and the **docs** got a glow-up!

### Features üöÄ

* **GitHub Action integration:** Pochi now lives in your PR comments / issues! Ask for help in a PR with `/pochi`. [#76](https://github.com/TabbyML/pochi/pull/76)
* **Internationalization (i18n):** The VS Code extension now supports üá∫üá∏ üá®üá≥ üáØüáµ üá∞üá∑. Want your language included? Open a PR! [#90](https://github.com/TabbyML/pochi/pull/90)

### Enhancements ‚ú®

* **CLI upgrades:** The Pochi CLI got a big boost this week!
  * Install via Homebrew üç∫ [#125](https://github.com/TabbyML/pochi/issues/125)
  * Authenticate with `pochi auth`, including support for Gemini login [#167](https://github.com/TabbyML/pochi/pull/167)
  * Trigger workflows directly with `pochi -p "/create-pr"` [#110](https://github.com/TabbyML/pochi/pull/110)
* **Enhanced Background jobs:** Added terminal integration and lifecycle controls. Enhanced the job UI with collapsible detail logs and readable IDs for a clearer experience. [#81](https://github.com/TabbyML/pochi/pull/81), [#97](https://github.com/TabbyML/pochi/pull/97)
* **Autocomplete:** Pochi suggests relevant tools, functions, and variables to help you type prompts faster. [#89](https://github.com/TabbyML/pochi/pull/89)
* **Documentation updates:** Refreshed CLI usage docs, expanded model provider configuration examples, and added Slack integration documentation. [#133](https://github.com/TabbyML/pochi/pull/133), [#141](https://github.com/TabbyML/pochi/pull/141), [#82](https://github.com/TabbyML/pochi/pull/82)

### Bug Fixes üêõ

* **File writing reliability:** The CLI ensures directories exist before writing, so `writeToFile` tool won't fail. [#118](https://github.com/TabbyML/pochi/pull/118)
* **Code completion fix:** Corrected how VS Code calculates the replacement range for suggestions, so completions insert correctly. [#131](https://github.com/TabbyML/pochi/pull/131)

### New Contributors üêæ

[@karim-coder](https://github.com/karim-coder) made their first contribution this week! Welcome aboard! üéâ


# Weekly Update
URL: /developer-updates/2025-09-12-weekly-update-3

***

## title: Weekly Update #3

# Weekly Update #3

### TL;DR

This week we brought **custom agents** to life!üê£ Pochi **CLI is on npm**, `newTask` makes it simple to create and manage tasks right from the terminal, and Mermaid diagrams render beautifully inside the app. MCP interactions are smarter too, and the docs and UI keep getting smoother with every update. ‚ú®

### Features üöÄ

* **Custom Agents:** Define your own assistants in `.pochi/agents` using markdown. [#176](https://github.com/TabbyML/pochi/pull/176), [#181](https://github.com/TabbyML/pochi/pull/181)
* **`newTask` in CLI:** Spin up tasks directly from the terminal, each with its dedicated agent. [#232](https://github.com/TabbyML/pochi/pull/232)
* **Mermaid diagrams:** Drop Mermaid code blocks into Pochi and see them rendered as nice diagrams. [#255](https://github.com/TabbyML/pochi/pull/255)

<div className="w-4/7 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Mermaid.js rendered diagram](./images/mermaid-js-diagram.png)</div>

### Enhancements ‚ú®

* **Pochi CLI on npm üì¶:** `npm install -g pochi` and get it running! [#238](https://github.com/TabbyML/pochi/pull/238)
* **Custom models for completion:** Use your own models for code completion in VS Code. [#251](https://github.com/TabbyML/pochi/pull/251)
* **MCP instructions:** MCP servers can now guide models on tool usage, enabling more complex interactions. [#254](https://github.com/TabbyML/pochi/pull/254)
* **Token auth:** Log in with a token when browser auth doesn't work. [#235](https://github.com/TabbyML/pochi/pull/235), [#236](https://github.com/TabbyML/pochi/pull/236)
* **Diff view focus mode:** Pochi automatically closes a file's regular editor tab when opening its diff view. [#197](https://github.com/TabbyML/pochi/pull/197)
* **More CLI commands:** `pochi mcp list` to inspect configured MCP servers, and `pochi task list` to check task lists. [#231](https://github.com/TabbyML/pochi/pull/231), [#266](https://github.com/TabbyML/pochi/pull/266)
  <div className="w-2/3">![Pochi CLI Task List](./images/cli-task-list.png)</div>
* **VS Code UI polish**: Autocomplete mention list is responsive and tabbable, workflow list is collapsible and better spaced. [#215](https://github.com/TabbyML/pochi/pull/215), [#204](https://github.com/TabbyML/pochi/pull/204), [#230](https://github.com/TabbyML/pochi/pull/230), [#228](https://github.com/TabbyML/pochi/pull/228), [#242](https://github.com/TabbyML/pochi/pull/242)
* **Docs updates:** Added checkpoint feature and updated GitHub integration docs with API key setup. [#203](https://github.com/TabbyML/pochi/pull/203), [#262](https://github.com/TabbyML/pochi/pull/262)

### Bug fixes üêõ

* **Scoped replies:** Pochi only responds when you start a comment with `/pochi`. [#202](https://github.com/TabbyML/pochi/pull/202)


# Weekly Update
URL: /developer-updates/2025-09-19-weekly-update-4

***

## title: Weekly Update #4

# Weekly Update #4

### TL;DR

We are excited to introduce **Queued Messages** ‚Äî type prompts in advance and stop waiting for Pochi to finish a task! We also launched a new [**Tutorials section**](https://docs.getpochi.com/tutorials/) with guides on **voice-driven development** and **Mermaid graphs**. Have tips or insights? Contribute your own via PRs! Plus, Pochi now supports more file types, and the CLI is friendlier and more interactive. ‚ú®

### Features üöÄ

* **[Queued Messages](https://docs.getpochi.com/queued-messages/):** Don't wait around ‚Äî `‚åò/Ctrl + ‚Üµ` to line up your next prompt when Pochi is busy. [#286](https://github.com/TabbyML/pochi/pull/286)
  <div className="w-4/7 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Queued messages in prompt editor](./images/queued-messages-1.png)</div>

* **[Tutorials](https://docs.getpochi.com/tutorials/):** A new documentation hub to help you get more out of Pochi. This week: [voice-driven dev with Hex](https://docs.getpochi.com/tutorials/hex/), and [Mermaid graph communication](https://docs.getpochi.com/tutorials/mermaid-graph/).

### Enhancements ‚ú®

* **Multimedia file support:** Share not just images, but also PDFs and videos with Pochi. [#271](https://github.com/TabbyML/pochi/pull/271)

* **Claude Code login:** The CLI now supports authentication with Claude Code. [#282](https://github.com/TabbyML/pochi/pull/282)

* **Friendlier CLI experience:** Interactively pick auth vendors and navigate through tasks, get clearer help/error messages, and see upgrade notices on startup. [#287](https://github.com/TabbyML/pochi/pull/287), [#294](https://github.com/TabbyML/pochi/pull/294), [#308](https://github.com/TabbyML/pochi/pull/308), [#329](https://github.com/TabbyML/pochi/pull/329), [#357](https://github.com/TabbyML/pochi/pull/357)
  <div className="w-4/7 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Interactive task list in terminal](./images/interactive-task-list.png)</div>

* **Docs updates**: Added documentation for [queued messages](https://docs.getpochi.com/queued-messages/) and [tab completion model settings](https://docs.getpochi.com/tab-completion/#tab-completion-model-settings) and improved VS Code docs. [#317](https://github.com/TabbyML/pochi/pull/317), [#321](https://github.com/TabbyML/pochi/pull/321), [#365](https://github.com/TabbyML/pochi/pull/365)

### Bug fixes üêõ

* **VS Code UX tweaks:** Unified drag-and-drop overlays with the prompt editor, fixed tooltip arrows, and ensured model selections are preserved with clear alerts when a model is unavailable. [#350](https://github.com/TabbyML/pochi/pull/350), [#316](https://github.com/TabbyML/pochi/pull/316), [#373](https://github.com/TabbyML/pochi/pull/373)

### New Contributors üêæ

A belated shout-out to [@DESU-CLUB](https://github.com/DESU-CLUB) for their first contribution last week ‚Äî and another one this week! ü•≥


# Rethink sub-agent context in AI Coding
URL: /developer-updates/2025-09-22-rethink-sub-agent-context

***

## title: Rethink sub-agent context in AI Coding

# Rethink sub-agent context in AI Coding


# Weekly Update
URL: /developer-updates/2025-09-26-weekly-update-5

***

## title: Weekly Update #5

# Weekly Update #5

### TL;DR

This release introduces a manual sub-task execution mode for more control over sensitive workflows. We‚Äôve also added MCP support in the CLI, enabled GitHub Copilot and Claude Pro/Max authentication, and shipped new tutorials and key security and stability improvements. üôå

### üöÄ Features

* **Manual Execution Mode for Sub-Tasks:** Sub-tasks created with `newTask` can now be run in a manual, step-by-step mode avoiding large unmoderated changes to your codebases in your sensitive workflows. **[#300](https://github.com/TabbyML/pochi/issues/300)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1AwiwI9uIv4Rf_r1rolCLMW38wWVZHP2y/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Manual Execution for Sub-tasks"
  />
</div>

* **MCP support in CLI:** The CLI now supports running your Model Context Protocol (MCP) servers, allowing you to connect your tools, and run MCP-powered workflows directly from the terminal. This update brings the CLI closer to parity with the VS Code extension. **[#100](https://github.com/TabbyML/pochi/issues/100)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1V8Ut_XXM9sRdSPHhoGVhMMnJHkxeaYFp/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="MCP Support in CLI"
  />
</div>

* **AI Tooling Integrations (GitHub Copilot + Claude):** You can now authenticate and use your GitHub Copilot and existing Claude Pro/Max subscriptions within Pochi across both the CLI and VS Code. Once authenticated, these services provide completions and suggestions directly in your workflows, enhancing the overall AI-assisted development experience. **[#184](https://github.com/TabbyML/pochi/issues/184) , [#61](https://github.com/TabbyML/pochi/issues/61), [#306](https://github.com/TabbyML/pochi/issues/306)**

  <div class="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Claude Support](./images/claude-copilot-support.png)</div>

* **Improved VS Code Configuration Navigation:** VS Code commands like `Pochi: Open MCP Server Settings` now open the relevant config file and jump directly to the specific setting, **[#301](https://github.com/TabbyML/pochi/issues/301)**

### ‚ú® Enhancements

* **Enhanced Gemini Model Support:** We've improved existing image input capabilities with added PDF and video inputs, providing richer multimodal workflows with Gemini models. **[#219](https://github.com/TabbyML/pochi/issues/219)**

* **Malformed Custom Agents in VSCode Settings:** Previously ignored malformed agent files (e.g., with YAML parsing errors) are now displayed in the settings UI with a clear warning, making it easier to debug and fix broken custom agent configurations. **[#391](https://github.com/TabbyML/pochi/issues/391)**, **[#415](https://github.com/TabbyML/pochi/issues/415)**

### üìñ Resources

* [Connect Pochi to Your Self-Hosted Tabby Server](https://docs.getpochi.com/tutorials/connect-to-tabby-server/)
* [Build a Custom MCP Server to Query Supabase](https://docs.getpochi.com/tutorials/supabase-mcp-server/)


# Weekly Update
URL: /developer-updates/2025-10-03-weekly-update-6

***

## title: Weekly Update #6

# Weekly Update #6

### TL;DR

Q4 is here, and Pochi‚Äôs cooking. üç≥

We‚Äôve rolled out new built-in tools (`webFetch` and `webSearch`) that extend Pochi‚Äôs server-side capabilities, added support for new AI vendors (**Codex** and **Qwen Coder**), and released a new tutorial that shows how Pochi can act as your AI teammate in GitHub Actions.

Let‚Äôs start! üß°

### üöÄ Features

* **Built-in Tools:** Pochi now supports server-side tools, allowing it to register and expose capabilities that come bundled directly with the app. The first two built-in tools introduced are `webFetch` and `webSearch`. These let AI agents fetch, read, and process web content directly. **[#447](https://github.com/TabbyML/pochi/issues/447)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1cnEtO1wlTyplQnQUvLbwTp6lp77esJHp/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Built in tools for MCP"
  />
</div>

* **New AI Vendor Support:** Pochi  now supports Qwen Coder and Codex, adding new model vendors alongside Claude, Gemini, and Copilot. We've also introduced native compatibility with Anthropic‚Äôs API format, enabling faster and more stable integration with Claude models. **[#52](https://github.com/TabbyML/pochi/issues/52)**, **[#304](https://github.com/TabbyML/pochi/issues/304)**, **[#302](https://github.com/TabbyML/pochi/issues/302)**

  <div class="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Codex / Qwen Support](./images/qwen-codex-support.png)</div>

### ‚ú® Enhancements

* **Model-Aware Workflows:** You can now define which model a workflow should use directly in its configuration. This gives you more control over which LLM handles each automation, especially useful if your team switches between providers like Claude, Gemini, or Codex. **[#343](https://github.com/TabbyML/pochi/issues/343)**

### üêõ Bug fixes

* **Assistant Retry Logic:** Fixed an issue where assistant messages without tool calls were treated as new steps instead of retries, causing the retry count logic to behave incorrectly. **[#342](https://github.com/TabbyML/pochi/issues/342)**

* **Diff View in VS Code:** Files open before a diff operation are now reopened after accepting or rejecting changes, preserving your workspace layout. **[#440](https://github.com/TabbyML/pochi/issues/440)**

### üìñ Resources

* We‚Äôve published a new tutorial: **[Build Your Own AI Teammate with Pochi in GitHub Actions](https://docs.getpochi.com/tutorials/pochi-github-actions/)**. Learn how Pochi can review and gatekeep PRs, enforce coding standards, open issues, and even run as a continuous background agent.


# Weekly Update
URL: /developer-updates/2025-10-14-weekly-update-7

***

## title: Weekly Update #7

# Weekly Update #7

### TL;DR

This week, we focused on making Pochi more capable for builders who live in the terminal.¬†We extended image-prompt support to the CLI, added global workflows for shared automations, and made the command-line experience smoother with shell autocompletion.

We‚Äôve also shipped `.pochiignore` support and small but delightful touches like copying images directly from the extension chat.

### üöÄ Features

* **CLI Autocompletion:** The Pochi CLI now supports shell autocompletion for `bash`, `zsh`, and `fish`.¬†Improve your flow as you discover commands, subcommands and options while typing, without the need to stop and check docs mid-flow. **[#307](https://github.com/TabbyML/pochi/issues/307)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1b99FOfdh5H_HZvAvJMibXW3v-QLOq8uo/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Shell autocomplete"
  />
</div>

* **Global Workflows:** You can now store workflows globally in `~/.pochi/workflows`, and Pochi will load them across all workspaces. Easily share automations, setups, or linting rules, while allowing your team to maintain consistent review or deployment routines.**[#123](https://github.com/TabbyML/pochi/issues/123)**, **[#517](https://github.com/TabbyML/pochi/issues/517)**

* **Image Prompts in CLI:** You can pass images directly to Pochi from the CLI, be it a diagram, a UI screenshot, or a flow chart. Models interpret and respond to your visuals, explaining issues, parsing charts and generating code based on UI mockups. **[#513](https://github.com/TabbyML/pochi/issues/513)**

### ‚ú® Enhancements

* **`.pochiignore` Support:** You can now use `.pochiignore` (just like `.gitignore`) to exclude files and directories from Pochi‚Äôs context, keeping your large repositories lean and your prompts focused on the task at hand. **[#515](https://github.com/TabbyML/pochi/issues/515)** , **[#516](https://github.com/TabbyML/pochi/issues/516)**<break />

```bash
# Example .pochiignore
node_modules/
dist/
*.log
```

* **Copy Images from MCP and Attachments:** You can now right-click any image generated by MCP tools or shared in chat to copy it to your clipboard or open it in an editor tab. A small addition, but a big win for anyone working with visual data or model-generated diagrams. **[#500](https://github.com/TabbyML/pochi/issues/500)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/13ib68zpqSpClaJqu2WLlKDInCvF_PslW/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Copy Images from MCP and Attachments"
  />
</div>

### üêõ Bug fixes

* **Command Queue Stability:** Fixed race conditions between queued and other requests (particularly during preview operations) to improve execution consistency and error handling. **[#528](https://github.com/TabbyML/pochi/issues/528)**


# Weekly Update
URL: /developer-updates/2025-10-21-weekly-update-8

***

## title: Weekly Update #8

# Weekly Update #8

### TL;DR

We‚Äôve given Pochi new tricks.

Workflows can now execute Bash commands, `readFile` tool handles multimedia inputs, and markdown rendering is faster and cleaner with `streamdown.ai`.

Let‚Äôs get on with it!

### üöÄ Features

* **Bash Commands in Workflows** You can now execute Bash commands directly inside Pochi workflows using the `!` prefix. This allows workflows to pull live system or repository context, like `git status` or `uname -a`, and feed the results into the model before running your task. <break />
  For example:

```bash
- With this: !`uname -a` and !`uptime` 
- Please show the system info and uptime
```

Pochi automatically runs these commands and includes their outputs in the model‚Äôs context, making workflows more dynamic and connected to your local environment. **[#541](https://github.com/TabbyML/pochi/issues/541)**

<div class="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Bash commands](./images/bash-commands.png)</div>

### ‚ú® Enhancements

* **Faster Markdown Rendering with `streamdown.ai`:**  We‚Äôve replaced `react-markdown` with `streamdown.ai` in the VS Code web UI. This upgrade improves performance, adds streaming-based markdown rendering, and ensures better support for rich content (like math, code blocks, and workflows). **[#401](https://github.com/TabbyML/pochi/issues/401)**

* **Extended Multimedia Support in `readFile` Tool:**  The `readFile` tool now supports reading multimedia files, including images, audio, and video, for multimodal models. Pochi automatically detects file types and encodes the content in `base64` for models that can interpret visual and auditory data. **[#539](https://github.com/TabbyML/pochi/issues/539)**, **[#569](https://github.com/TabbyML/pochi/issues/569)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1q-ghZRyqMIhuOFA-k5E8xRbYRvdXZdSC/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="`readfile`tool demo"
  />
</div>

* **Added Linux ARM64 Release:** Pochi is now available for Linux ARM64 systems, improving compatibility for developers running on Raspberry Pi or ARM-based environments. **[#543](https://github.com/TabbyML/pochi/issues/543)**


# Weekly Update
URL: /developer-updates/2025-11-01-weekly-update-9

***

## title: Weekly Update #9

# Weekly Update #9

### TL;DR

**Custom Agent** gets even better ‚ö° + **i18n** upgrades for global users üåè! And major Chat Sidebar UX upgrades are coming soon! üöÄ

### üöÄ Features

* **Custom Agent with Slash Section:** You can now invoke **custom agents directly through slash commands** in the VS Code chat sidebar ‚Äî just like how you trigger workflows. **[#567](https://github.com/TabbyML/pochi/issues/567)**

This change unifies how agents and workflows are invoked, creating a more intuitive and consistent experience for interacting with Pochi‚Äôs capabilities.

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1fTfCldtoy54Oma5Szzhcramus77FjSNF/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="`readfile`tool demo"
  />
</div>

* **Chat UI i18n:** We are bringing full **internationalization** to the chat UI!‚ú® Hardcoded strings are being replaced with our i18n system (powered by `i18next`), paving the way for a localized experience in English, Chinese, Japanese, and Korean. **[#201](https://github.com/TabbyML/pochi/issues/201)**

### ‚ú® Preview

We‚Äôre actively working on a series of UX improvements to the VS Code chat sidebar, aimed at making Pochi more seamless and intuitive to use.
Stay tuned for the upcoming update!


# Launching Parallel Agents
URL: /developer-updates/2025-11-11-launch-parallel-agent

***

## title: Launching Parallel Agents

# Launching Parallel Agents

Teams rarely work on a single task at a time. You might be part-way through a feature when a bug report arrives, someone needs a small refactor reviewed, or a documentation fix is pending. Most tools and workflows force these tasks to share one working state.

So you end up switching branches, stashing and popping changes, resetting your workspace, and trying to hold the original task in your head. This is context switching, and it‚Äôs one of the biggest hidden costs in software development.

We released **Parallel Agents** to remove that cost. Each agent runs in its own Git worktree, which isolates the task‚Äôs state from the rest of your work.

<div class="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Parallel Agent](./images/parallel-agents-changelog.png)</div>

A great example would be to run the same task with different models to pick the best response. Won‚Äôt that be a faster and much better experience - all within the same timeframe?

This is different from other existing solutions, which operate inside a single editor tab. In those tools, you‚Äôre effectively working in one tab at a time: switching tasks means switching the state of the same working directory and the same conversation.

On the other hand, **Parallel Agents** in Pochi keep tasks fully isolated by running each one in its own Git worktree. You can keep multiple tasks active at once and switch between them without stashing or losing context.

## How to use?

1. You can create a worktree from the Pochi sidebar. Once a worktree exists, starting a task in that worktree opens it as its own tab in Pochi.
2. When a task finishes, use the diff view to review its changes. If it looks good, create a PR from that worktree.

## When to use Parallel Agents

**Parallel Agents** are most useful when you want to avoid breaking focus on ongoing work: quick bugfixes during feature development, long-running refactors that you want to keep separate, documentation changes that happen alongside coding, or letting an AI assistant explore broader changes in a sandbox.

On the other hand, if a change is meant to be reviewed and merged as a single unit, keeping it on one branch remains simpler.

Here is the demo showing the feature in action:

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1JB3viOn2nawUX5JNMdGVHWPVJvBraJTY/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Parallel Agents Demo"
  />
</div>

Read the full documentation **[here](https://docs.getpochi.com/parallel-agents/)**.


# Weekly Update
URL: /developer-updates/2025-11-13-weekly-update-10

***

## title: Weekly Update #10

# Weekly Update #10

### TL;DR

We added modular `@import` rules and fixed PDF handling in `readFile`. Behind the scenes, we‚Äôre preparing two big improvements: smart task notifications and a refreshed, faster tab-completion experience.

### ‚ú® Enhancements

* **Modular Rules with `@import` Syntax:** You can now split and organize large rule files by importing other markdown files using the `@` prefix (e.g. `@./rules/api-guidelines.md`). Pochi will stitch them together, managing complex configurations for your multi-agent or multi-project setups. **[#540](https://github.com/TabbyML/pochi/issues/540)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/18s3_3KyoA02aUefK7zmMJirWljW_QOFF/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Modular rules"
  />
</div>

### üêõ Bug fixes

* **PDF Handling in `readFile`:** Resolved a bug that caused `readFile` to return PDF files as plain text. **[#591](https://github.com/TabbyML/pochi/issues/591)**

### üî• Preview

* **Smart Task Notifications:** Pochi will now show real-time notifications when a task needs your input, completes, or fails. Notifications will include a ‚ÄúView Details‚Äù button to jump directly into the task, and will be automatically suppressed when the task panel is already open to avoid duplicates.

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1ytoU6d11rd-Sv-jQsqLmOvI_WxKqqwzO/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="`readfile`tool demo"
  />
</div>

* We‚Äôre also preparing an upgrade to our tab completion system to make suggestions feel faster and more intuitive. More details coming soon!


# Weekly Update
URL: /developer-updates/2025-11-21-weekly-update-11

***

## title: Weekly Update #11

# Weekly Update #11

### TL;DR

This week was a big one.

We shipped Next Edit Suggestions (one of our biggest upgrades so far), along with real-time task notifications and cleaner diff views. Pochi now feels smarter, tighter, and much more intuitive across the codebase.

### üöÄ Features

* **Next Edit Suggestions (NES):** We‚Äôve introduced our internal edit model powering Next Edit Suggestion (NES). It is an upgrade to Tab Completion that predicts the next change your code needs, wherever it lives. It learns from your recent edits, understands how your file is evolving, and auto-surfaces likely follow-up edits. <br /> <br />We‚Äôve published a deep-dive on how we trained and evaluated the edit model, and how it powers Pochi's experience. You can read more **[here](./how-we-created-nes-model.mdx)**.

<div class="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg">![NES Demo](./images/nes-demo-blog.gif)</div>

* **Pop-up Notifications for Task Status Changes:** Pochi now shows real-time notifications when a task completes, fails, or needs your input. Each notification includes a ‚ÄúView Details‚Äù button that jumps directly into the task. In the case the task panel is already open, we suppress duplicable notifications to reduce noise.

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1ytoU6d11rd-Sv-jQsqLmOvI_WxKqqwzO/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Task notifications"
  />
</div>

* **Gemini 3 Support:** We‚Äôve added support for Gemini 3 Pro alongside 2.5 Pro. The UI for model selection is updated and ready for you to take over!
  <div class="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Gemini 3 Support](./images/gemini-3pro-support.png)</div>

### ‚ú® Enhancements

* **Line Wrap Toggle in Code Blocks:** We added a line wrap toggle to the code block component in the VS Code extension. This way, long lines inside diffs and model edits are now way easier to read, especially when reviewing wide changes across generated code.

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1MYevQHoKri44vn4UCe7zvNGJqkXJNfQ4/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Line Wrap Toggle in Code Blocks:"
  />
</div>

### üî• Preview

* We‚Äôre actively working on a set of UX upgrades for the VS Code sidebar - things like grouping tasks by worktree, cleaner task headers, and a diff-summary panel that shows all file edits at a glance. More on this in an upcoming update.


# Weekly Update
URL: /developer-updates/2025-11-28-weekly-update-12

***

## title: Weekly Update #12

# Weekly Update #12

### TL;DR

This weeks update is packed with improvements to task visibility, worktree workflows, and NES accuracy. We also made foundational changes to how tasks are stored, which sets us up for upcoming GitHub and multi-worktree features.

<Callout type="info" title="Breaking Change: Task list reset in v0.16.0">
  We introduced a breaking change in v0.16.0 that may result in the loss of the task list after upgrading. No action is needed as new tasks will behave normally going forward.
</Callout>

### üöÄ Features

* **Diff Summary Panel for Task Changes:** We added a diff summary panel inside each task, showing all file edits made during execution. You can now review per-file additions/deletions, inspect the total change summary, and undo changes directly from the panel itself. **[#728](https://github.com/TabbyML/pochi/issues/728)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/11Z1go6JzvuQ-uOijAyOd8cZ0lmVd4zBx/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Diff Summary Panel for Task Changes"
  />
</div>

### ‚ú® Enhancements

* **Improved Visibility into Task Execution:** Tasks now display real-time execution details, including active tool calls, subtasks, and streaming progress to make task behavior easier to understand at a glance. This brings much clearer visibility into what Pochi is doing while a task runs. **[#675](https://github.com/TabbyML/pochi/issues/675)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1FV0KxcbzgcPbTKCfa3js9zaZv5PoOCr0/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Improved Visibility into Task Execution"
  />
</div>

* **Tasks grouped by worktree:** Pochi automatically groups tasks by their associated Git worktree with active worktrees at the top and deleted worktrees collapsed into a dedicated section. Each worktree shows its own tasks, status, and metadata which makes it much easier to manage parallel workstreams and multiple agents. **[#676](https://github.com/TabbyML/pochi/issues/676)**
  <div class="w-3/6 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Tasks grouped by worktree](./images/tasks-grouped-by-worktree.png)</div>

* **Diff Summary on Task List Item:** Task rows now display git diff summaries (e.g. `+23 -5`) so you can instantly see the size and impact of each task‚Äôs changes across multiple worktrees. **[#674](https://github.com/TabbyML/pochi/issues/674)**
  <div class="w-3/6 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Diff Summary on Task List Item](./images/diff-summary-on-task-list-item.png)</div>

* **Worktree-aware task tabs:** Pochi now opens tasks from the same Git worktree in the same VS Code tab group, and tasks from different worktrees in separate tab groups. This keeps parallel branches visually separated while you work. **[#677](https://github.com/TabbyML/pochi/issues/677)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1Q-i632-wzbT04-HkWukqXGst7QKNn-LA/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Worktree-aware task tabs"
  />
</div>

* **Unread Task Indicators:** We added unread indicators to the task list so you never miss when a background task finishes or fails. Tasks that complete while you‚Äôre looking elsewhere now show a small dot until you open them, making it much easier to track updates. **[#673](https://github.com/TabbyML/pochi/issues/673)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1XCqsNtZI-_I7mon0CIyIKpAF8p_BmbEt/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Unread Task Indicators"
  />
</div>

* **Enhanced NES prompting with additional local code context:** NES now includes richer local code context in its prompt, improving accuracy for predictions that depend on nearby functions, variables, or imports. **[#727](https://github.com/TabbyML/pochi/issues/727)**

### üî• Preview

* We‚Äôre actively working on GitHub PR creation and status, multi-worktree task execution, and GitHub/Linear issue linking - all designed to make Pochi even more powerful for real engineering workflows.


# NES Series (Part 1): The Edit Model Behind Tab Completion
URL: /developer-updates/how-we-created-nes-model
Inside the engineering behind how we trained our next edit model
***

title: 'NES Series (Part 1): The Edit Model Behind Tab Completion'
description: "Inside the engineering behind how we trained our next edit model"
image: "/og-image/nes-part-1-og-image.png"
------------------------------------------

# NES Series (Part 1): The Edit Model Behind Tab Completion

In this post, we‚Äôre introducing our internal edit model, the foundation behind Next Edit Suggestion (NES). It‚Äôs an upgrade to Tab completion, designed to predict the next change your code needs, wherever it lives.

Technically this is much harder to achieve, since NES considers the entire file plus your recent edit history and predicts how your code is likely to evolve: where the next change should happen, and what that change should be.

![NES Cover Image](./images/cover-nes.png)

Other editors have explored versions of next-edit prediction, but models have evolved a lot, and so has our understanding of how people actually write code.

As an open-source team, we want to share this work transparently. This is the first post in our "Next Edit Suggestion" series, where we walk you through how we trained the underlying model to how it powers real-time editing inside the extension.

![NES Demo](./images/nes-demo-blog.gif)

## How We Train the Edit Model

When we decided to build NES, one of the first pressing questions on our mind was: What kind of data actually teaches a model to make good edits?

It turned out that real developer intent is surprisingly hard to capture. As anyone who‚Äôs peeked at real commits knows, developer edits are messy. Pull requests bundle unrelated changes, commit histories jump around, and the sequences of edits often skip the small, incremental steps engineers actually take when exploring or fixing code.

### The Training Process

To train an edit model, we format each example using special edit tokens. These tokens tell the model:

* What part of the file is editable
* The user‚Äôs cursor position
* What the user has edited so far
* What the next edit should be inside that region only

Unlike chat-style models that generate free-form text, NES is trained to predict the next code edit inside the editable region.

Below is an example of how NES predicts the next edit:

![SFT conversion image](./images/sft-conversion-image.png)

In the image above, the developer makes the first edit allowing the model to capture the intent of the user. The `editable_region` markers define everything between them as the editable zone. The `user_cursor_is_here` token shows the model where the user is currently editing.

NES infers the transformation pattern (capitalization in this case) and applies it consistently as the next edit sequence.

To support this training format, we used **[CommitPackFT](https://huggingface.co/datasets/bigcode/commitpackft)** and **[Zeta](https://huggingface.co/datasets/zed-industries/zeta)** as data sources. We normalized this unified dataset into the same Zeta-derived edit-markup format as described above and applied filtering to remove non-sequential edits using a small in-context model (GPT-4.1 mini).

## Choosing the Base Model for NES

With the training format and dataset finalized, the next major decision was choosing what base model to fine-tune. Initially, we considered both open-source and managed models, but ultimately chose Gemini 2.5 Flash Lite for two main reasons:

* **Easy serving:** Running an OSS model would require us to manage its inference and scalability in production. For a feature as latency-sensitive as Next Edit, these operational pieces matter as much as the model weights themselves. Using a managed model helped us avoid all these operational overheads.

* **Simple supervised-fine-tuning:** We fine-tuned NES using **[Google‚Äôs Gemini Supervised Fine-Tuning (SFT) API](https://docs.cloud.google.com/vertex-ai/generative-ai/docs/models/gemini-use-supervised-tuning)**, with no training loop to maintain, no GPU provisioning, and at the same price as the regular Gemini inference API. Under the hood, Flash Lite uses LoRA (Low-Rank Adaptation), which means we update only a small set of parameters rather than the full model. This keeps NES lightweight and preserves the base model‚Äôs broader coding ability.

Overall, in practice, using Flash Lite gave us model quality comparable to strong open-source baselines, with the obvious advantage of far lower operational costs. We can  , keeping the model stable across versions.

### Why this matters for you

Using Flash Lite directly improves the user experience in the editor. As a user, you can expect faster responses and likely lower compute cost (which can translate into cheaper product).

And since fine-tuning is lightweight, we can roll out frequent improvements, providing a more robust service with less risk of downtime, scaling issues, or version drift; meaning greater reliability for everyone.

## How we evaluated the model

We evaluated our edit model using a single metric: LLM-as-a-Judge, powered by **Gemini 2.5 Pro**. This judge model evaluates whether a predicted edit is semantically correct, logically consistent with recent edits, and appropriate for the given context. This is unlike token-level comparisons and makes it far closer to how a human engineer would judge an edit.

In practice, this gave us an evaluation process that is scalable, automated, and far more sensitive to intent than simple string matching. It allowed us to run large evaluation suites continuously as we retrain and improve the model.

## Enhancing Context at Inference

Training and evaluation only define what the model knows in theory. To make Next Edit Suggestions feel alive inside the editor, the model needs to understand what you are doing right now. So at inference time, we give the model more than just the current file snapshot. We also send:

1. Your recent edit history
   Wrapped in `<|edit_history|>`, this gives the model a short story of your current flow: what changed, in what order, and what direction the code seems to be moving.

2. Additional semantic context
   Added via `<|additional_context|>`, this might include type signatures, documentation, or relevant parts of the broader codebase. It‚Äôs the kind of stuff you would mentally reference before making the next edit.

Here‚Äôs a small example image showing the full inference-time context with the edit history, additional context, and the live editable region which the NES model receives:

![Additional context while predicting the next edit](./images/additional-context-image.png)

NES combines these inputs to infer the user‚Äôs intent from earlier edits and predict the next edit inside the editable region only.

In this post, we‚Äôve focused on how the model is trained and evaluated. In the next post, we‚Äôll go deeper into how these dynamic contexts are constructed, ranked, and streamed into the model to drive real-time, context-aware edit predictions.


# Developer Updates
URL: /developer-updates
Weekly update notes from Pochi developers
***

title: "Developer Updates"
icon: "Newspaper"
description: "Weekly update notes from Pochi developers"
--------------------------------------------------------

Welcome to the Pochi Developer Updates ‚Äî a **digest** of what's new in the codebase.

Here you will find highlights on features, enhancements, and bug fixes, plus insights into how we're improving the developer experience. Come back often! üëã

***

{/* ## [Rethink sub-agent context in AI Coding](./2025-09-22-rethink-sub-agent-context)

  ### Sep 22, 2025

  --- */}

## [Weekly Update #12](./2025-11-28-weekly-update-12)

#### Nov 28, 2025

# Weekly Update #12

### TL;DR

This weeks update is packed with improvements to task visibility, worktree workflows, and NES accuracy. We also made foundational changes to how tasks are stored, which sets us up for upcoming GitHub and multi-worktree features.

<Callout type="info" title="Breaking Change: Task list reset in v0.16.0">
  We introduced a breaking change in v0.16.0 that may result in the loss of the task list after upgrading. No action is needed as new tasks will behave normally going forward.
</Callout>

### üöÄ Features

* **Diff Summary Panel for Task Changes:** We added a diff summary panel inside each task, showing all file edits made during execution. You can now review per-file additions/deletions, inspect the total change summary, and undo changes directly from the panel itself. **[#728](https://github.com/TabbyML/pochi/issues/728)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/11Z1go6JzvuQ-uOijAyOd8cZ0lmVd4zBx/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Diff Summary Panel for Task Changes"
  />
</div>

### ‚ú® Enhancements

* **Improved Visibility into Task Execution:** Tasks now display real-time execution details, including active tool calls, subtasks, and streaming progress to make task behavior easier to understand at a glance. This brings much clearer visibility into what Pochi is doing while a task runs. **[#675](https://github.com/TabbyML/pochi/issues/675)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1FV0KxcbzgcPbTKCfa3js9zaZv5PoOCr0/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Improved Visibility into Task Execution"
  />
</div>

* **Tasks grouped by worktree:** Pochi automatically groups tasks by their associated Git worktree with active worktrees at the top and deleted worktrees collapsed into a dedicated section. Each worktree shows its own tasks, status, and metadata which makes it much easier to manage parallel workstreams and multiple agents. **[#676](https://github.com/TabbyML/pochi/issues/676)**
  <div class="w-3/6 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Tasks grouped by worktree](./images/tasks-grouped-by-worktree.png)</div>

* **Diff Summary on Task List Item:** Task rows now display git diff summaries (e.g. `+23 -5`) so you can instantly see the size and impact of each task‚Äôs changes across multiple worktrees. **[#674](https://github.com/TabbyML/pochi/issues/674)**
  <div class="w-3/6 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Diff Summary on Task List Item](./images/diff-summary-on-task-list-item.png)</div>

* **Worktree-aware task tabs:** Pochi now opens tasks from the same Git worktree in the same VS Code tab group, and tasks from different worktrees in separate tab groups. This keeps parallel branches visually separated while you work. **[#677](https://github.com/TabbyML/pochi/issues/677)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1Q-i632-wzbT04-HkWukqXGst7QKNn-LA/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Worktree-aware task tabs"
  />
</div>

* **Unread Task Indicators:** We added unread indicators to the task list so you never miss when a background task finishes or fails. Tasks that complete while you‚Äôre looking elsewhere now show a small dot until you open them, making it much easier to track updates. **[#673](https://github.com/TabbyML/pochi/issues/673)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1XCqsNtZI-_I7mon0CIyIKpAF8p_BmbEt/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Unread Task Indicators"
  />
</div>

* **Enhanced NES prompting with additional local code context:** NES now includes richer local code context in its prompt, improving accuracy for predictions that depend on nearby functions, variables, or imports. **[#727](https://github.com/TabbyML/pochi/issues/727)**

### üî• Preview

* We‚Äôre actively working on GitHub PR creation and status, multi-worktree task execution, and GitHub/Linear issue linking - all designed to make Pochi even more powerful for real engineering workflows.

***

## [Weekly Update #11](./2025-11-21-weekly-update-11)

#### Nov 21, 2025

# Weekly Update #11

### TL;DR

This week was a big one.

We shipped Next Edit Suggestions (one of our biggest upgrades so far), along with real-time task notifications and cleaner diff views. Pochi now feels smarter, tighter, and much more intuitive across the codebase.

### üöÄ Features

* **Next Edit Suggestions (NES):** We‚Äôve introduced our internal edit model powering Next Edit Suggestion (NES). It is an upgrade to Tab Completion that predicts the next change your code needs, wherever it lives. It learns from your recent edits, understands how your file is evolving, and auto-surfaces likely follow-up edits. <br /> <br />We‚Äôve published a deep-dive on how we trained and evaluated the edit model, and how it powers Pochi's experience. You can read more **[here](./how-we-created-nes-model.mdx)**.

<div class="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg">![NES Demo](./images/nes-demo-blog.gif)</div>

* **Pop-up Notifications for Task Status Changes:** Pochi now shows real-time notifications when a task completes, fails, or needs your input. Each notification includes a ‚ÄúView Details‚Äù button that jumps directly into the task. In the case the task panel is already open, we suppress duplicable notifications to reduce noise.

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1ytoU6d11rd-Sv-jQsqLmOvI_WxKqqwzO/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Task notifications"
  />
</div>

* **Gemini 3 Support:** We‚Äôve added support for Gemini 3 Pro alongside 2.5 Pro. The UI for model selection is updated and ready for you to take over!
  <div class="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Gemini 3 Support](./images/gemini-3pro-support.png)</div>

### ‚ú® Enhancements

* **Line Wrap Toggle in Code Blocks:** We added a line wrap toggle to the code block component in the VS Code extension. This way, long lines inside diffs and model edits are now way easier to read, especially when reviewing wide changes across generated code.

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1MYevQHoKri44vn4UCe7zvNGJqkXJNfQ4/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Line Wrap Toggle in Code Blocks:"
  />
</div>

### üî• Preview

* We‚Äôre actively working on a set of UX upgrades for the VS Code sidebar - things like grouping tasks by worktree, cleaner task headers, and a diff-summary panel that shows all file edits at a glance. More on this in an upcoming update.

***

## [NES Series (Part 1): The Edit Model Behind Tab Completion](./how-we-created-nes-model)

#### Nov 19, 2025

# NES Series (Part 1): The Edit Model Behind Tab Completion

In this post, we‚Äôre introducing our internal edit model, the foundation behind Next Edit Suggestion (NES). It‚Äôs an upgrade to Tab completion, designed to predict the next change your code needs, wherever it lives.

Technically this is much harder to achieve, since NES considers the entire file plus your recent edit history and predicts how your code is likely to evolve: where the next change should happen, and what that change should be.

![NES Cover Image](./images/cover-nes.png)

Other editors have explored versions of next-edit prediction, but models have evolved a lot, and so has our understanding of how people actually write code.

As an open-source team, we want to share this work transparently. This is the first post in our "Next Edit Suggestion" series, where we walk you through how we trained the underlying model to how it powers real-time editing inside the extension.

![NES Demo](./images/nes-demo-blog.gif)

## How We Train the Edit Model

When we decided to build NES, one of the first pressing questions on our mind was: What kind of data actually teaches a model to make good edits?

It turned out that real developer intent is surprisingly hard to capture. As anyone who‚Äôs peeked at real commits knows, developer edits are messy. Pull requests bundle unrelated changes, commit histories jump around, and the sequences of edits often skip the small, incremental steps engineers actually take when exploring or fixing code.

### The Training Process

To train an edit model, we format each example using special edit tokens. These tokens tell the model:

* What part of the file is editable
* The user‚Äôs cursor position
* What the user has edited so far
* What the next edit should be inside that region only

Unlike chat-style models that generate free-form text, NES is trained to predict the next code edit inside the editable region.

Below is an example of how NES predicts the next edit:

![SFT conversion image](./images/sft-conversion-image.png)

In the image above, the developer makes the first edit allowing the model to capture the intent of the user. The `editable_region` markers define everything between them as the editable zone. The `user_cursor_is_here` token shows the model where the user is currently editing.

NES infers the transformation pattern (capitalization in this case) and applies it consistently as the next edit sequence.

To support this training format, we used **[CommitPackFT](https://huggingface.co/datasets/bigcode/commitpackft)** and **[Zeta](https://huggingface.co/datasets/zed-industries/zeta)** as data sources. We normalized this unified dataset into the same Zeta-derived edit-markup format as described above and applied filtering to remove non-sequential edits using a small in-context model (GPT-4.1 mini).

## Choosing the Base Model for NES

With the training format and dataset finalized, the next major decision was choosing what base model to fine-tune. Initially, we considered both open-source and managed models, but ultimately chose Gemini 2.5 Flash Lite for two main reasons:

* **Easy serving:** Running an OSS model would require us to manage its inference and scalability in production. For a feature as latency-sensitive as Next Edit, these operational pieces matter as much as the model weights themselves. Using a managed model helped us avoid all these operational overheads.

* **Simple supervised-fine-tuning:** We fine-tuned NES using **[Google‚Äôs Gemini Supervised Fine-Tuning (SFT) API](https://docs.cloud.google.com/vertex-ai/generative-ai/docs/models/gemini-use-supervised-tuning)**, with no training loop to maintain, no GPU provisioning, and at the same price as the regular Gemini inference API. Under the hood, Flash Lite uses LoRA (Low-Rank Adaptation), which means we update only a small set of parameters rather than the full model. This keeps NES lightweight and preserves the base model‚Äôs broader coding ability.

Overall, in practice, using Flash Lite gave us model quality comparable to strong open-source baselines, with the obvious advantage of far lower operational costs. We can  , keeping the model stable across versions.

### Why this matters for you

Using Flash Lite directly improves the user experience in the editor. As a user, you can expect faster responses and likely lower compute cost (which can translate into cheaper product).

And since fine-tuning is lightweight, we can roll out frequent improvements, providing a more robust service with less risk of downtime, scaling issues, or version drift; meaning greater reliability for everyone.

## How we evaluated the model

We evaluated our edit model using a single metric: LLM-as-a-Judge, powered by **Gemini 2.5 Pro**. This judge model evaluates whether a predicted edit is semantically correct, logically consistent with recent edits, and appropriate for the given context. This is unlike token-level comparisons and makes it far closer to how a human engineer would judge an edit.

In practice, this gave us an evaluation process that is scalable, automated, and far more sensitive to intent than simple string matching. It allowed us to run large evaluation suites continuously as we retrain and improve the model.

## Enhancing Context at Inference

Training and evaluation only define what the model knows in theory. To make Next Edit Suggestions feel alive inside the editor, the model needs to understand what you are doing right now. So at inference time, we give the model more than just the current file snapshot. We also send:

1. Your recent edit history
   Wrapped in `<|edit_history|>`, this gives the model a short story of your current flow: what changed, in what order, and what direction the code seems to be moving.

2. Additional semantic context
   Added via `<|additional_context|>`, this might include type signatures, documentation, or relevant parts of the broader codebase. It‚Äôs the kind of stuff you would mentally reference before making the next edit.

Here‚Äôs a small example image showing the full inference-time context with the edit history, additional context, and the live editable region which the NES model receives:

![Additional context while predicting the next edit](./images/additional-context-image.png)

NES combines these inputs to infer the user‚Äôs intent from earlier edits and predict the next edit inside the editable region only.

In this post, we‚Äôve focused on how the model is trained and evaluated. In the next post, we‚Äôll go deeper into how these dynamic contexts are constructed, ranked, and streamed into the model to drive real-time, context-aware edit predictions.

***

## [Weekly Update #10](./2025-11-13-weekly-update-10)

#### Nov 13, 2025

# Weekly Update #10

### TL;DR

We added modular `@import` rules and fixed PDF handling in `readFile`. Behind the scenes, we‚Äôre preparing two big improvements: smart task notifications and a refreshed, faster tab-completion experience.

### ‚ú® Enhancements

* **Modular Rules with `@import` Syntax:** You can now split and organize large rule files by importing other markdown files using the `@` prefix (e.g. `@./rules/api-guidelines.md`). Pochi will stitch them together, managing complex configurations for your multi-agent or multi-project setups. **[#540](https://github.com/TabbyML/pochi/issues/540)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/18s3_3KyoA02aUefK7zmMJirWljW_QOFF/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Modular rules"
  />
</div>

### üêõ Bug fixes

* **PDF Handling in `readFile`:** Resolved a bug that caused `readFile` to return PDF files as plain text. **[#591](https://github.com/TabbyML/pochi/issues/591)**

### üî• Preview

* **Smart Task Notifications:** Pochi will now show real-time notifications when a task needs your input, completes, or fails. Notifications will include a ‚ÄúView Details‚Äù button to jump directly into the task, and will be automatically suppressed when the task panel is already open to avoid duplicates.

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1ytoU6d11rd-Sv-jQsqLmOvI_WxKqqwzO/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="`readfile`tool demo"
  />
</div>

* We‚Äôre also preparing an upgrade to our tab completion system to make suggestions feel faster and more intuitive. More details coming soon!

***

## [Launching Parallel Agents](./2025-11-11-launch-parallel-agent)

#### Nov 11, 2025

# Launching Parallel Agents

Teams rarely work on a single task at a time. You might be part-way through a feature when a bug report arrives, someone needs a small refactor reviewed, or a documentation fix is pending. Most tools and workflows force these tasks to share one working state.

So you end up switching branches, stashing and popping changes, resetting your workspace, and trying to hold the original task in your head. This is context switching, and it‚Äôs one of the biggest hidden costs in software development.

We released **Parallel Agents** to remove that cost. Each agent runs in its own Git worktree, which isolates the task‚Äôs state from the rest of your work.

<div class="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Parallel Agent](./images/parallel-agents-changelog.png)</div>

A great example would be to run the same task with different models to pick the best response. Won‚Äôt that be a faster and much better experience - all within the same timeframe?

This is different from other existing solutions, which operate inside a single editor tab. In those tools, you‚Äôre effectively working in one tab at a time: switching tasks means switching the state of the same working directory and the same conversation.

On the other hand, **Parallel Agents** in Pochi keep tasks fully isolated by running each one in its own Git worktree. You can keep multiple tasks active at once and switch between them without stashing or losing context.

## How to use?

1. You can create a worktree from the Pochi sidebar. Once a worktree exists, starting a task in that worktree opens it as its own tab in Pochi.
2. When a task finishes, use the diff view to review its changes. If it looks good, create a PR from that worktree.

## When to use Parallel Agents

**Parallel Agents** are most useful when you want to avoid breaking focus on ongoing work: quick bugfixes during feature development, long-running refactors that you want to keep separate, documentation changes that happen alongside coding, or letting an AI assistant explore broader changes in a sandbox.

On the other hand, if a change is meant to be reviewed and merged as a single unit, keeping it on one branch remains simpler.

Here is the demo showing the feature in action:

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1JB3viOn2nawUX5JNMdGVHWPVJvBraJTY/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Parallel Agents Demo"
  />
</div>

Read the full documentation **[here](https://docs.getpochi.com/parallel-agents/)**.

***

## [Weekly Update #9](./2025-11-01-weekly-update-9)

#### Nov 01, 2025

# Weekly Update #9

### TL;DR

**Custom Agent** gets even better ‚ö° + **i18n** upgrades for global users üåè! And major Chat Sidebar UX upgrades are coming soon! üöÄ

### üöÄ Features

* **Custom Agent with Slash Section:** You can now invoke **custom agents directly through slash commands** in the VS Code chat sidebar ‚Äî just like how you trigger workflows. **[#567](https://github.com/TabbyML/pochi/issues/567)**

This change unifies how agents and workflows are invoked, creating a more intuitive and consistent experience for interacting with Pochi‚Äôs capabilities.

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1fTfCldtoy54Oma5Szzhcramus77FjSNF/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="`readfile`tool demo"
  />
</div>

* **Chat UI i18n:** We are bringing full **internationalization** to the chat UI!‚ú® Hardcoded strings are being replaced with our i18n system (powered by `i18next`), paving the way for a localized experience in English, Chinese, Japanese, and Korean. **[#201](https://github.com/TabbyML/pochi/issues/201)**

### ‚ú® Preview

We‚Äôre actively working on a series of UX improvements to the VS Code chat sidebar, aimed at making Pochi more seamless and intuitive to use.
Stay tuned for the upcoming update!

***

## [Weekly Update #8](./2025-10-21-weekly-update-8)

#### Oct 21, 2025

# Weekly Update #8

### TL;DR

We‚Äôve given Pochi new tricks.

Workflows can now execute Bash commands, `readFile` tool handles multimedia inputs, and markdown rendering is faster and cleaner with `streamdown.ai`.

Let‚Äôs get on with it!

### üöÄ Features

* **Bash Commands in Workflows** You can now execute Bash commands directly inside Pochi workflows using the `!` prefix. This allows workflows to pull live system or repository context, like `git status` or `uname -a`, and feed the results into the model before running your task. <break />
  For example:

```bash
- With this: !`uname -a` and !`uptime` 
- Please show the system info and uptime
```

Pochi automatically runs these commands and includes their outputs in the model‚Äôs context, making workflows more dynamic and connected to your local environment. **[#541](https://github.com/TabbyML/pochi/issues/541)**

<div class="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Bash commands](./images/bash-commands.png)</div>

### ‚ú® Enhancements

* **Faster Markdown Rendering with `streamdown.ai`:**  We‚Äôve replaced `react-markdown` with `streamdown.ai` in the VS Code web UI. This upgrade improves performance, adds streaming-based markdown rendering, and ensures better support for rich content (like math, code blocks, and workflows). **[#401](https://github.com/TabbyML/pochi/issues/401)**

* **Extended Multimedia Support in `readFile` Tool:**  The `readFile` tool now supports reading multimedia files, including images, audio, and video, for multimodal models. Pochi automatically detects file types and encodes the content in `base64` for models that can interpret visual and auditory data. **[#539](https://github.com/TabbyML/pochi/issues/539)**, **[#569](https://github.com/TabbyML/pochi/issues/569)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1q-ghZRyqMIhuOFA-k5E8xRbYRvdXZdSC/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="`readfile`tool demo"
  />
</div>

* **Added Linux ARM64 Release:** Pochi is now available for Linux ARM64 systems, improving compatibility for developers running on Raspberry Pi or ARM-based environments. **[#543](https://github.com/TabbyML/pochi/issues/543)**

***

## [Weekly Update #7](./2025-10-14-weekly-update-7)

#### Oct 14, 2025

# Weekly Update #7

### TL;DR

This week, we focused on making Pochi more capable for builders who live in the terminal.¬†We extended image-prompt support to the CLI, added global workflows for shared automations, and made the command-line experience smoother with shell autocompletion.

We‚Äôve also shipped `.pochiignore` support and small but delightful touches like copying images directly from the extension chat.

### üöÄ Features

* **CLI Autocompletion:** The Pochi CLI now supports shell autocompletion for `bash`, `zsh`, and `fish`.¬†Improve your flow as you discover commands, subcommands and options while typing, without the need to stop and check docs mid-flow. **[#307](https://github.com/TabbyML/pochi/issues/307)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1b99FOfdh5H_HZvAvJMibXW3v-QLOq8uo/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Shell autocomplete"
  />
</div>

* **Global Workflows:** You can now store workflows globally in `~/.pochi/workflows`, and Pochi will load them across all workspaces. Easily share automations, setups, or linting rules, while allowing your team to maintain consistent review or deployment routines.**[#123](https://github.com/TabbyML/pochi/issues/123)**, **[#517](https://github.com/TabbyML/pochi/issues/517)**

* **Image Prompts in CLI:** You can pass images directly to Pochi from the CLI, be it a diagram, a UI screenshot, or a flow chart. Models interpret and respond to your visuals, explaining issues, parsing charts and generating code based on UI mockups. **[#513](https://github.com/TabbyML/pochi/issues/513)**

### ‚ú® Enhancements

* **`.pochiignore` Support:** You can now use `.pochiignore` (just like `.gitignore`) to exclude files and directories from Pochi‚Äôs context, keeping your large repositories lean and your prompts focused on the task at hand. **[#515](https://github.com/TabbyML/pochi/issues/515)** , **[#516](https://github.com/TabbyML/pochi/issues/516)**<break />

```bash
# Example .pochiignore
node_modules/
dist/
*.log
```

* **Copy Images from MCP and Attachments:** You can now right-click any image generated by MCP tools or shared in chat to copy it to your clipboard or open it in an editor tab. A small addition, but a big win for anyone working with visual data or model-generated diagrams. **[#500](https://github.com/TabbyML/pochi/issues/500)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/13ib68zpqSpClaJqu2WLlKDInCvF_PslW/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Copy Images from MCP and Attachments"
  />
</div>

### üêõ Bug fixes

* **Command Queue Stability:** Fixed race conditions between queued and other requests (particularly during preview operations) to improve execution consistency and error handling. **[#528](https://github.com/TabbyML/pochi/issues/528)**

***

## [Weekly Update #6](./2025-10-03-weekly-update-6)

#### Oct 03, 2025

# Weekly Update #6

### TL;DR

Q4 is here, and Pochi‚Äôs cooking. üç≥

We‚Äôve rolled out new built-in tools (`webFetch` and `webSearch`) that extend Pochi‚Äôs server-side capabilities, added support for new AI vendors (**Codex** and **Qwen Coder**), and released a new tutorial that shows how Pochi can act as your AI teammate in GitHub Actions.

Let‚Äôs start! üß°

### üöÄ Features

* **Built-in Tools:** Pochi now supports server-side tools, allowing it to register and expose capabilities that come bundled directly with the app. The first two built-in tools introduced are `webFetch` and `webSearch`. These let AI agents fetch, read, and process web content directly. **[#447](https://github.com/TabbyML/pochi/issues/447)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1cnEtO1wlTyplQnQUvLbwTp6lp77esJHp/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Built in tools for MCP"
  />
</div>

* **New AI Vendor Support:** Pochi  now supports Qwen Coder and Codex, adding new model vendors alongside Claude, Gemini, and Copilot. We've also introduced native compatibility with Anthropic‚Äôs API format, enabling faster and more stable integration with Claude models. **[#52](https://github.com/TabbyML/pochi/issues/52)**, **[#304](https://github.com/TabbyML/pochi/issues/304)**, **[#302](https://github.com/TabbyML/pochi/issues/302)**

  <div class="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Codex / Qwen Support](./images/qwen-codex-support.png)</div>

### ‚ú® Enhancements

* **Model-Aware Workflows:** You can now define which model a workflow should use directly in its configuration. This gives you more control over which LLM handles each automation, especially useful if your team switches between providers like Claude, Gemini, or Codex. **[#343](https://github.com/TabbyML/pochi/issues/343)**

### üêõ Bug fixes

* **Assistant Retry Logic:** Fixed an issue where assistant messages without tool calls were treated as new steps instead of retries, causing the retry count logic to behave incorrectly. **[#342](https://github.com/TabbyML/pochi/issues/342)**

* **Diff View in VS Code:** Files open before a diff operation are now reopened after accepting or rejecting changes, preserving your workspace layout. **[#440](https://github.com/TabbyML/pochi/issues/440)**

### üìñ Resources

* We‚Äôve published a new tutorial: **[Build Your Own AI Teammate with Pochi in GitHub Actions](https://docs.getpochi.com/tutorials/pochi-github-actions/)**. Learn how Pochi can review and gatekeep PRs, enforce coding standards, open issues, and even run as a continuous background agent.

***

## [Weekly Update #5](./2025-09-26-weekly-update-5)

#### Sep 26, 2025

# Weekly Update #5

### TL;DR

This release introduces a manual sub-task execution mode for more control over sensitive workflows. We‚Äôve also added MCP support in the CLI, enabled GitHub Copilot and Claude Pro/Max authentication, and shipped new tutorials and key security and stability improvements. üôå

### üöÄ Features

* **Manual Execution Mode for Sub-Tasks:** Sub-tasks created with `newTask` can now be run in a manual, step-by-step mode avoiding large unmoderated changes to your codebases in your sensitive workflows. **[#300](https://github.com/TabbyML/pochi/issues/300)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1AwiwI9uIv4Rf_r1rolCLMW38wWVZHP2y/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Manual Execution for Sub-tasks"
  />
</div>

* **MCP support in CLI:** The CLI now supports running your Model Context Protocol (MCP) servers, allowing you to connect your tools, and run MCP-powered workflows directly from the terminal. This update brings the CLI closer to parity with the VS Code extension. **[#100](https://github.com/TabbyML/pochi/issues/100)**

<div
  className="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg"
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1V8Ut_XXM9sRdSPHhoGVhMMnJHkxeaYFp/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="MCP Support in CLI"
  />
</div>

* **AI Tooling Integrations (GitHub Copilot + Claude):** You can now authenticate and use your GitHub Copilot and existing Claude Pro/Max subscriptions within Pochi across both the CLI and VS Code. Once authenticated, these services provide completions and suggestions directly in your workflows, enhancing the overall AI-assisted development experience. **[#184](https://github.com/TabbyML/pochi/issues/184) , [#61](https://github.com/TabbyML/pochi/issues/61), [#306](https://github.com/TabbyML/pochi/issues/306)**

  <div class="w-12/15 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Claude Support](./images/claude-copilot-support.png)</div>

* **Improved VS Code Configuration Navigation:** VS Code commands like `Pochi: Open MCP Server Settings` now open the relevant config file and jump directly to the specific setting, **[#301](https://github.com/TabbyML/pochi/issues/301)**

### ‚ú® Enhancements

* **Enhanced Gemini Model Support:** We've improved existing image input capabilities with added PDF and video inputs, providing richer multimodal workflows with Gemini models. **[#219](https://github.com/TabbyML/pochi/issues/219)**

* **Malformed Custom Agents in VSCode Settings:** Previously ignored malformed agent files (e.g., with YAML parsing errors) are now displayed in the settings UI with a clear warning, making it easier to debug and fix broken custom agent configurations. **[#391](https://github.com/TabbyML/pochi/issues/391)**, **[#415](https://github.com/TabbyML/pochi/issues/415)**

### üìñ Resources

* [Connect Pochi to Your Self-Hosted Tabby Server](https://docs.getpochi.com/tutorials/connect-to-tabby-server/)
* [Build a Custom MCP Server to Query Supabase](https://docs.getpochi.com/tutorials/supabase-mcp-server/)

***

## [Weekly Update #4](./2025-09-19-weekly-update-4)

#### Sep 19, 2025

# Weekly Update #4

### TL;DR

We are excited to introduce **Queued Messages** ‚Äî type prompts in advance and stop waiting for Pochi to finish a task! We also launched a new [**Tutorials section**](https://docs.getpochi.com/tutorials/) with guides on **voice-driven development** and **Mermaid graphs**. Have tips or insights? Contribute your own via PRs! Plus, Pochi now supports more file types, and the CLI is friendlier and more interactive. ‚ú®

### Features üöÄ

* **[Queued Messages](https://docs.getpochi.com/queued-messages/):** Don't wait around ‚Äî `‚åò/Ctrl + ‚Üµ` to line up your next prompt when Pochi is busy. [#286](https://github.com/TabbyML/pochi/pull/286)
  <div className="w-4/7 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Queued messages in prompt editor](./images/queued-messages-1.png)</div>

* **[Tutorials](https://docs.getpochi.com/tutorials/):** A new documentation hub to help you get more out of Pochi. This week: [voice-driven dev with Hex](https://docs.getpochi.com/tutorials/hex/), and [Mermaid graph communication](https://docs.getpochi.com/tutorials/mermaid-graph/).

### Enhancements ‚ú®

* **Multimedia file support:** Share not just images, but also PDFs and videos with Pochi. [#271](https://github.com/TabbyML/pochi/pull/271)

* **Claude Code login:** The CLI now supports authentication with Claude Code. [#282](https://github.com/TabbyML/pochi/pull/282)

* **Friendlier CLI experience:** Interactively pick auth vendors and navigate through tasks, get clearer help/error messages, and see upgrade notices on startup. [#287](https://github.com/TabbyML/pochi/pull/287), [#294](https://github.com/TabbyML/pochi/pull/294), [#308](https://github.com/TabbyML/pochi/pull/308), [#329](https://github.com/TabbyML/pochi/pull/329), [#357](https://github.com/TabbyML/pochi/pull/357)
  <div className="w-4/7 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Interactive task list in terminal](./images/interactive-task-list.png)</div>

* **Docs updates**: Added documentation for [queued messages](https://docs.getpochi.com/queued-messages/) and [tab completion model settings](https://docs.getpochi.com/tab-completion/#tab-completion-model-settings) and improved VS Code docs. [#317](https://github.com/TabbyML/pochi/pull/317), [#321](https://github.com/TabbyML/pochi/pull/321), [#365](https://github.com/TabbyML/pochi/pull/365)

### Bug fixes üêõ

* **VS Code UX tweaks:** Unified drag-and-drop overlays with the prompt editor, fixed tooltip arrows, and ensured model selections are preserved with clear alerts when a model is unavailable. [#350](https://github.com/TabbyML/pochi/pull/350), [#316](https://github.com/TabbyML/pochi/pull/316), [#373](https://github.com/TabbyML/pochi/pull/373)

### New Contributors üêæ

A belated shout-out to [@DESU-CLUB](https://github.com/DESU-CLUB) for their first contribution last week ‚Äî and another one this week! ü•≥

***

## [Weekly Update #3](./2025-09-12-weekly-update-3)

#### Sep 12, 2025

# Weekly Update #3

### TL;DR

This week we brought **custom agents** to life!üê£ Pochi **CLI is on npm**, `newTask` makes it simple to create and manage tasks right from the terminal, and Mermaid diagrams render beautifully inside the app. MCP interactions are smarter too, and the docs and UI keep getting smoother with every update. ‚ú®

### Features üöÄ

* **Custom Agents:** Define your own assistants in `.pochi/agents` using markdown. [#176](https://github.com/TabbyML/pochi/pull/176), [#181](https://github.com/TabbyML/pochi/pull/181)
* **`newTask` in CLI:** Spin up tasks directly from the terminal, each with its dedicated agent. [#232](https://github.com/TabbyML/pochi/pull/232)
* **Mermaid diagrams:** Drop Mermaid code blocks into Pochi and see them rendered as nice diagrams. [#255](https://github.com/TabbyML/pochi/pull/255)

<div className="w-4/7 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Mermaid.js rendered diagram](./images/mermaid-js-diagram.png)</div>

### Enhancements ‚ú®

* **Pochi CLI on npm üì¶:** `npm install -g pochi` and get it running! [#238](https://github.com/TabbyML/pochi/pull/238)
* **Custom models for completion:** Use your own models for code completion in VS Code. [#251](https://github.com/TabbyML/pochi/pull/251)
* **MCP instructions:** MCP servers can now guide models on tool usage, enabling more complex interactions. [#254](https://github.com/TabbyML/pochi/pull/254)
* **Token auth:** Log in with a token when browser auth doesn't work. [#235](https://github.com/TabbyML/pochi/pull/235), [#236](https://github.com/TabbyML/pochi/pull/236)
* **Diff view focus mode:** Pochi automatically closes a file's regular editor tab when opening its diff view. [#197](https://github.com/TabbyML/pochi/pull/197)
* **More CLI commands:** `pochi mcp list` to inspect configured MCP servers, and `pochi task list` to check task lists. [#231](https://github.com/TabbyML/pochi/pull/231), [#266](https://github.com/TabbyML/pochi/pull/266)
  <div className="w-2/3">![Pochi CLI Task List](./images/cli-task-list.png)</div>
* **VS Code UI polish**: Autocomplete mention list is responsive and tabbable, workflow list is collapsible and better spaced. [#215](https://github.com/TabbyML/pochi/pull/215), [#204](https://github.com/TabbyML/pochi/pull/204), [#230](https://github.com/TabbyML/pochi/pull/230), [#228](https://github.com/TabbyML/pochi/pull/228), [#242](https://github.com/TabbyML/pochi/pull/242)
* **Docs updates:** Added checkpoint feature and updated GitHub integration docs with API key setup. [#203](https://github.com/TabbyML/pochi/pull/203), [#262](https://github.com/TabbyML/pochi/pull/262)

### Bug fixes üêõ

* **Scoped replies:** Pochi only responds when you start a comment with `/pochi`. [#202](https://github.com/TabbyML/pochi/pull/202)

***

## [Weekly Update #2](./2025-09-05-weekly-update-2)

#### Sep 5, 2025

# Weekly Update #2

### TL;DR

We had a massive week ‚Äî **62 PRs shipped** üéâ!

Pochi can now reply to you right in **GitHub comments & issues**, the interface speaks more languages with new **i18n support**, and we rolled out a sleeker, more powerful **background job system**. On top of that, the **CLI** got smarter, **autocomplete** got friendlier, and the **docs** got a glow-up!

### Features üöÄ

* **GitHub Action integration:** Pochi now lives in your PR comments / issues! Ask for help in a PR with `/pochi`. [#76](https://github.com/TabbyML/pochi/pull/76)
* **Internationalization (i18n):** The VS Code extension now supports üá∫üá∏ üá®üá≥ üáØüáµ üá∞üá∑. Want your language included? Open a PR! [#90](https://github.com/TabbyML/pochi/pull/90)

### Enhancements ‚ú®

* **CLI upgrades:** The Pochi CLI got a big boost this week!
  * Install via Homebrew üç∫ [#125](https://github.com/TabbyML/pochi/issues/125)
  * Authenticate with `pochi auth`, including support for Gemini login [#167](https://github.com/TabbyML/pochi/pull/167)
  * Trigger workflows directly with `pochi -p "/create-pr"` [#110](https://github.com/TabbyML/pochi/pull/110)
* **Enhanced Background jobs:** Added terminal integration and lifecycle controls. Enhanced the job UI with collapsible detail logs and readable IDs for a clearer experience. [#81](https://github.com/TabbyML/pochi/pull/81), [#97](https://github.com/TabbyML/pochi/pull/97)
* **Autocomplete:** Pochi suggests relevant tools, functions, and variables to help you type prompts faster. [#89](https://github.com/TabbyML/pochi/pull/89)
* **Documentation updates:** Refreshed CLI usage docs, expanded model provider configuration examples, and added Slack integration documentation. [#133](https://github.com/TabbyML/pochi/pull/133), [#141](https://github.com/TabbyML/pochi/pull/141), [#82](https://github.com/TabbyML/pochi/pull/82)

### Bug Fixes üêõ

* **File writing reliability:** The CLI ensures directories exist before writing, so `writeToFile` tool won't fail. [#118](https://github.com/TabbyML/pochi/pull/118)
* **Code completion fix:** Corrected how VS Code calculates the replacement range for suggestions, so completions insert correctly. [#131](https://github.com/TabbyML/pochi/pull/131)

### New Contributors üêæ

[@karim-coder](https://github.com/karim-coder) made their first contribution this week! Welcome aboard! üéâ

***

## [Weekly Update #1](./2025-08-29-weekly-update-1)

#### Aug 29, 2025

# Weekly Update #1

### TL;DR

This week we polished the VS Code extension with some **UX upgrades**, open-sourced the **Pochi CLI**, and did a few rounds of **codebase cleanup** to make contributing easier and friendlier for newcomers. We look forward to your first visit to the repo!

### Enhancements ‚ú®

* **Drag & drop images:** Share visuals with Pochi in the VS Code chat just by dragging them in. [#64](https://github.com/TabbyML/pochi/pull/64)
* **Improved docs:** Updated structure and added guidance on model settings for easier use. [#60](https://github.com/TabbyML/pochi/pull/60), [#63](https://github.com/TabbyML/pochi/pull/63) , [900d162](https://github.com/TabbyML/pochi/commit/900d1629c4e97833e24a4450c438a585dca583d4)
* **Model pricing at your fingertips:** Check model costs directly in settings before choosing one. [#74](https://github.com/TabbyML/pochi/pull/74)

### Bug Fixes üêõ

* **File search now correctly surfaces matching files:** Queries that used to return empty results will now behave as expected. [#79](https://github.com/TabbyML/pochi/pull/79)


# Connect to Tabby Server for Enhanced Enterprise Experience
URL: /tutorials/connect-to-tabby-server

***

## title: Connect to Tabby Server for Enhanced Enterprise Experience

# Connect to Tabby Server for Enhanced Enterprise Experience

This tutorial will guide you through the process of connecting Pochi to your self-hosted Tabby server. By connecting Pochi to your self-hosted Tabby server, you can take advantage of several benefits, including centralized account management, self-hosted tracking, and the ability to use your own custom models.

## Prerequisites

Before you start, make sure you have a running Tabby server instance. If you don't have one, you can follow the instructions on the [Tabby website](https://tabby.tabbyml.com/) to set one up.

## Configuration

Pochi uses a configuration file to connect to different model providers. To connect to Tabby, you'll need to add a new provider configuration to your `~/.pochi/config.json` file.

Here's a sample configuration for connecting to a Tabby server:

```jsonc
{
    "kind": "openai",
    "id": "tabby",
    "baseURL": "https://demo.tabbyml.com/v1",
    "apiKey": "YOUR_AUTH_TOKEN",
    "models": [
        {
            "id": "default",
            // This flag is important for Tabby to work properly with Pochi
            "useToolCallMiddleware": true
        }
    ]
}
```

### Parameters

You'll need to change the following parameters in the configuration:

* `baseURL`: Change this to the URL of your Tabby server instance.
* `apiKey`: Change this to your own auth token from the Tabby UI. You can find your token in the "Token" section of the Tabby admin panel, as shown in the screenshot below.

<div align="center">
  ![Tabby Auth Token](./images/tabby-auth-token.png)
</div>

## Conclusion

Once you have updated the configuration file, Pochi will be able to connect to your Tabby server and use the models you have configured.


# Voice-Driven Development with Handy and Pochi
URL: /tutorials/handy

***

## title: 'Voice-Driven Development with Handy and Pochi'

# Voice-Driven Development with Handy and Pochi

This tutorial guides you through setting up an efficient, voice-driven development workflow by combining two powerful tools: **[Handy](https://github.com/cjpais/Handy)** for local voice transcription and **[Pochi](https://github.com/TabbyML/pochi)** as your AI coding assistant.

This setup allows you to speak commands, have them transcribed into text by Handy, and then have Pochi execute those commands, creating a seamless, hands-free coding experience that keeps your audio on-device.

### What You Will Learn

* How to install and configure Handy for offline voice-to-text transcription.
* How to integrate Handy with Pochi to create a voice-driven development workflow.
* Tips for optimizing your setup for accuracy and efficiency.

### Prerequisites

* **Pochi**: You should have Pochi installed and running in your editor.
* **Handy**: Downloadable for macOS, Windows, and Linux from the official releases page.
* **Microphone and accessibility permissions**: Handy needs access to your microphone and the ability to paste text into other applications.

### How It Works

* **Handy** listens to your voice and converts it into text using on-device transcription models (Whisper or Parakeet).
* **Pochi** takes the text generated by Handy as a command and processes it using its configured AI model.

> **For a Fully Private Workflow**
> This tutorial focuses on the voice input aspect. For complete privacy and offline use, you can configure Pochi to use a local Large Language Model (LLM). See Pochi's documentation on [model configuration](../../models) for more details.

***

## Step 1: Install and Configure Handy

Handy is a cross-platform desktop application built with Tauri that records your voice via a keyboard shortcut and pastes the transcribed text into any application.

1. **Download Handy**: Get the latest version from the [official releases page](https://github.com/cjpais/Handy/releases) or the project website [handy.computer](https://handy.computer).

2. **Install and Grant Permissions**:
   * **macOS**: Open the downloaded `.dmg`, drag Handy into your `Applications` folder, and launch it once. Grant **Microphone** and **Accessibility** permissions when prompted so Handy can record audio and paste text.
   * **Windows**: Run the installer, then allow Handy to access the microphone. You may need to approve the accessibility overlay so Handy can send keystrokes.
   * **Linux**: Make the AppImage executable (e.g., `chmod +x Handy-x86_64.AppImage`), run it, and approve microphone/input permissions as required by your desktop environment.

3. **Configure Handy Settings**:

   **A. Set Your Hotkey**
   Choose a shortcut that does not conflict with other apps. Handy supports both push-to-talk and toggle behaviors. Enable `Push to Talk` if you want to hold the shortcut while speaking; otherwise, use the default press-to-start, press-again-to-stop mode.

   ![Handy hotkey settings window showing push-to-talk options](./images/hotkey-setting.png)

   **B. Select Your Transcription Engine**
   Handy can run multiple local transcription models:

   * **Whisper models (Small/Medium/Turbo/Large)** for GPU-accelerated accuracy on macOS, Windows, and Linux.
   * **Parakeet V3** for fast CPU-only transcription with automatic language detection.

   ![Handy transcription engine settings highlighting Whisper and Parakeet options](./images/transcription-model-setting.png)

   **C. Download Your Model**

   The first time you pick a model, Handy downloads and optimizes it. This may take several minutes and will temporarily increase CPU usage.

   **D. Customize Output Behavior**
   Tune options such as automatic text pasting, capitalization, and whether Handy should clear or append text after each recording.

## Step 2: The Voice Coding Workflow in Action

With Handy installed, let's try the workflow.

1. **Open Pochi**: Launch Pochi's chat interface in your code editor.

2. **Activate Handy**: Click inside Pochi's input box, then use the shortcut you configured for Handy. Handy shows an on-screen indicator when it is listening.

   ![Handy recording indicator overlay on macOS](./images/recording-indicator.png)

3. **Speak Your Command**: Clearly state the task you want Pochi to perform. For example:

   > Write a TypeScript function that takes an array of strings and returns the longest one.

4. **Transcription**: When you stop recording, Handy transcribes your speech and pastes the text into Pochi's input box (or copies it to the clipboard, depending on your settings).

5. **Execution**: Pochi sends the text to its configured AI model for processing. The generated code or response appears in the chat.

## Tips and Troubleshooting

* **Inaccurate Transcription?**
  Try switching to a larger Whisper model or to Parakeet V3 for improved accuracy on CPU-only systems.

* **Performance Concerns?**
  Smaller Whisper models consume fewer resources. If latency is high, choose a smaller model or use Parakeet V3.

* **Need Help with Handy?**
  Open an issue on the [GitHub repository](https://github.com/cjpais/Handy/issues).

## Conclusion

By combining Handy and Pochi, you've created a fast and efficient voice-powered programming environment. This setup gives you a modern, hands-free way to translate your ideas into code while keeping the entire transcription pipeline on your device.


# Tutorials
URL: /tutorials

***

title: Tutorials
icon: BookOpenText
------------------

# Tutorials

Welcome to the Pochi tutorials section. Here you will find step-by-step guides to help you get the most out of Pochi.

* [Build Your Own AI Teammate with Pochi in GitHub Actions](./pochi-github-actions)
* [Connect to Tabby Server for Enhanced Enterprise Experience](./connect-to-tabby-server)
* [Build a Custom MCP Server to Query Supabase with Natural Language in Pochi](./supabase-mcp-server)
* [Visual Communication with Mermaid Graphs](./mermaid-graph)
* [Voice-Driven Development with Handy and Pochi](./handy)


# Visualizing the Dialogue: How Pochi Uses Mermaid Graphs to Communicate
URL: /tutorials/mermaid-graph

***

## title: "Visualizing the Dialogue: How Pochi Uses Mermaid Graphs to Communicate"

# Visualizing the Dialogue: How Pochi Uses Mermaid Graphs to Communicate

When Pochi tackles a large-scale code change, a monologue of text and code is not an effective way to collaborate. To have a clear dialogue with you, Pochi translates its plans into **Mermaid graphs**.

Think of these diagrams as Pochi's whiteboard, where it sketches out its ideas for you to review. It's a communication tool designed to turn a complex plan into a simple, visual conversation. This allows you to understand, approve, and guide Pochi's approach before it writes a single line of code.

## A Visual Conversation for Complex Tasks

Pochi automatically generates Mermaid graphs when it needs to discuss its plan for complex tasks, such as:

* **Architectural Changes**: Showing how the overall structure of your application will be modified.
* **Complex Refactoring**: Breaking down a large function or class into smaller pieces.
* **New Feature Implementation**: Visualizing how a new feature will interact with existing components.

## Example: Pochi Proposes a Complex Refactor

When preparing for a significant refactoring, Pochi uses a diagram to discuss the proposed architecture with you. In this example, Pochi was asked to refactor a component for Server-Side Rendering (SSR). It first analyzed the code, then generated the following diagram to explain its findings and get your feedback.

![Tool Invocation Architecture](./images/tool-invocation-architecture.png)

This diagram provides a clear overview of the system, which was then used to formulate a refactoring plan. The analysis highlighted several key areas:

### Core Components:

* **ToolInvocationPart**: The main entry point that routes tools to the correct renderer.
* **Tools Registry**: A static mapping of tool names to their corresponding React components.
* **McpToolCall**: A specialized renderer for tools using the Model Context Protocol (MCP).
* **Shared UI Components**: A library of reusable components like containers, icons, and badges.

### SSR Challenges Identified:

The diagram helped identify three major challenges for implementing SSR:

1. **Client-Side State Dependencies**: Heavy reliance on React hooks (`useState`, `useCallback`) and context providers for managing the tool lifecycle, which are not available on the server.
2. **Browser/Environment Dependencies**: Components with direct dependencies on browser-specific features like `XTerm.js`, VS Code APIs, and file system interactions.
3. **Dynamic Component Resolution**: The architecture relies on a runtime tool registry and conditional rendering based on the tool's execution state, which is difficult to resolve on the server.

By visualizing the architecture, Pochi enabled the user to quickly understand the problem and approve the proposed strategy.

## Example: Pochi Clarifies Business Logic with a Flowchart

For changes to business logic, a code diff can be hard to follow. Pochi uses flowcharts to walk you through the new logic step-by-step. When asked to modify a task persistence feature, Pochi generated this flowchart to explain the new process.

![Task Persistence Flowchart](./images/persist-task-flow.png)

This visual explanation makes it much easier to verify the correctness of the new logic:

1. **Time Check**: The process starts with a throttling mechanism to prevent spamming the API.
2. **API Call**: If the check passes, it queries messages and calls the persistence API.
3. **Error Handling**: It includes a clear path for what happens if the API call fails.
4. **State Update**: It shows how the local state is updated with a `shareId` upon success.

This turns a code review into a collaborative check of the logic, ensuring you and Pochi are on the same page.

## Conclusion: Your Dialogue with Pochi

Mermaid graphs are more than just diagrams; they are the bridge for communication between you and Pochi. They transform a potential monologue of code into a clear, interactive dialogue about the best path forward.

When you see Pochi generate a Mermaid graph, it's an invitation to collaborate. Take a moment to review it‚Äîyour feedback is crucial for guiding the AI and ensuring the final result meets your exact expectations.

And remember, this is a two-way conversation. If you ever feel that Pochi's plan is unclear, you can proactively ask it to generate a Mermaid graph. Just say, "Can you explain that with a Mermaid diagram?" This puts you in control, allowing you to request visual clarity whenever you need it.


# Build Your Own AI Teammate with Pochi in GitHub Actions
URL: /tutorials/pochi-github-actions
Learn how to use Pochi to automate GitHub Actions, PR reviews, CI/CD, and more.
***

title: 'Build Your Own AI Teammate with Pochi in GitHub Actions'
description: "Learn how to use Pochi to automate GitHub Actions, PR reviews, CI/CD, and more."
image: "/og-image/github-actions-with-pochi-architecture-og-image.png"
----------------------------------------------------------------------

# Build Your Own AI Teammate with Pochi in GitHub Actions

In this tutorial, we‚Äôll learn how you can go beyond the basics of GitHub Actions and extend your workflows with Pochi, an AI agent that can make your everyday automations more powerful.

This means, instead of being limited to tests and deployments, we‚Äôll use Pochi to review pull requests, gatekeep PRs, enforce coding standards, draft changelogs, open issues, and even run as a continuous background agent.

![Architectural Diagram](./images/github-actions-with-pochi-architecture.png)

Throughout the tutorial, each use case builds on the last, so you‚Äôll see Pochi evolve from a simple reviewer into a full-fledged agent that embeds intelligence inside your development workflow.

## Automating Your Code Reviews and CI/CD Pipelines with Pochi

### Create your Demo Repo

Let‚Äôs begin by connecting Pochi to your GitHub repository so it can review pull requests when you ask it to. To do that, you‚Äôll need to go to **[Github](https://www.github.com)** and log in with your account. On the top right you need to click the ‚Äò+ button‚Äô and select ‚ÄòNew repository‚Äô.

You‚Äôll need to fill in:

* Repository name: `pochi-actions-demo`
* Description: `Testing Pochi GitHub Actions integration`
* Choose `Public` (so you get unlimited Actions minutes).
* Check Add a `README` file (makes life easier).

![Create Repository](./images/create-repository.png)

Finally, click `Create repository`. You now have an empty repository with a README file.

### Get Your Pochi API key

Next we need to get your Pochi API key. Head over to **[app.getpochi.com](app.getpochi.com)** and log in. In the top-right corner, you need to click your profile menu and then ‚ÄòAPI keys‚Äô.

![Pochi Profile Menu](./images/create-pochi-api-key.png)

Click on ‚ÄòNew API key‚Äô and give it a name like `github-actions-demo`.

![Create Pochi API key](./images/create-pochi-api-key-modal.png)

Copy the key and store it securely, it will only be shown once.

![Pochi API keys](./images/pochi-api-keys.png)

Now, in order for GitHub Actions to access Pochi securely, you need to add the API key in the repository. Head over to your GitHub repository ‚Üí Settings tabs ‚Üí Secrets and Variables ‚Üí Actions ‚Üí New repository secret.

![Create Repository Secret](./images/create-repository-secret.png)

Here you can create a secret called `POCHI_API_KEY` and paste your key value. Now we‚Äôre all set up!

## Use Case 1: Pochi as Your Code Reviewer

We‚Äôll create our first Pochi review in GitHub Actions. To get started, go to your repository, click the 'Add file' button  and 'Create new file'.

Set the file path to `.github/workflows/pochi.yml`.

Now paste in this YAML:

```yaml
name: Pochi PR Assistant

on:
  issue_comment:
    types: [created]

jobs:
  pochi:
    if: startsWith(github.event.comment.body, '/pochi')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Pochi
        uses: tabbyml/pochi/packages/github-action@main
        env:
          POCHI_API_KEY: ${{ secrets.POCHI_API_KEY }}
```

Scroll down and commit the changes directly to `main` branch.  At this point, your Pochi GitHub Action is ready to run.

To test this out, we‚Äôll create a sample pull request. To make it feel more realistic and production-like, let‚Äôs set up something meaningful to analyze.

For Use Case 1, since Pochi will be reviewing our code, we‚Äôll create a small full-stack Node.js + TypeScript + React snippet with a few intentional mistakes (bad naming, missing error handling, inconsistent types). This way, Pochi‚Äôs review will surface meaningful feedback.

Head over to your repo main page and add a file `src/server.ts` which will be our Express backend. Paste in the following:

```javascript
import express from "express";

const app = express();
app.use(express.json());

let users: { id: number; name: string }[] = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
];

// Bad: endpoint mixes concerns, no validation, no error handling
app.post("/addUser", (req, res) => {
  const { id, name } = req.body;
  users.push({ id, name }); // No duplicate check!
  res.send("ok");
});

// Bad: synchronous filter instead of proper DB, missing 404 handling
app.get("/getUser/:id", (req, res) => {
  const user = users.filter((u) => u.id == parseInt(req.params.id))[0];
  res.json(user);
});

app.listen(3000, () => {
  console.log("Server started on port 3000");
});
```

On the React frontend side, you can create a `src/components/UserList.tsx` file. Paste in the following:

```javascript
import React, { useEffect, useState } from "react";

type User = {
  id: number;
  name: string;
};

export default function UserList() {
  const [users, setUsers] = useState<User[]>([]);

  // Bad: hardcoded API URL, no error handling, no loading state
  useEffect(() => {
    fetch("http://localhost:3000/getUser/1")
      .then((res) => res.json())
      .then((data) => setUsers([data]));
  }, []);

  return (
    <div>
      <h2>Users</h2>
      <ul>
        {users.map((u) => (
          <li key={u.id}>{u.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

After committing your changes, create a new branch, for example, `feat/test`. Click `Propose changes`, and GitHub will prompt you to open a pull request from your branch. Open the pull request.

Here, you simply need to put a comment starting with `/pochi` to see your workflow in action:

```
/pochi review this code

```

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1DC71yPU5ZzhnA2Au7_ZArgvNHgEET3tn/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Pochi review code"
  />
</div>

You can see Pochi comments on things like no input validation / error handling in backend, data management issues and more. This is exactly the kind of review we wanted in the first place.

Now that we got Pochi to review the code and point out the flaws, wouldn't it be useful if Pochi could also apply suggestions automatically, fix the code, and commit it? You can easily do that by again commenting directly in the PR:

```
/pochi apply fixes and show the full updated code

```

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1_ZHh30s2XSOQEF-YQaoTYwRrNCHQ2WEc/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Pochi fix code"
  />
</div>

## Use Case 2: Automate Reviews Based on Events

So far, we‚Äôve seen Pochi respond when you type `/pochi` either on an issue or a pull request. That‚Äôs great, but we can go further. Now, we‚Äôll make Pochi respond automatically to repository events like when a PR is opened or when you push commits to `main`.

Based on what we‚Äôve seen so far, we'll need to add another workflow and test by opening a PR. The event of opening the PR should trigger the workflow since we‚Äôre doing event based triggers and we don‚Äôt need to type `/pochi` for this use case.

But there are two things we need to address: why we need a separate workflow file, and what custom GitHub tokens (PATs) are.

### Why a separate workflow file?

Your original `.github/workflows/pochi.yml` is the engine that runs Pochi when it sees `/pochi` comments. Now we‚Äôll be creating a new `.github/workflows/pochi-auto-comments.yml` which will be just a trigger that posts those comments automatically. Keeping them separate makes it easier to read / debug later especially if you‚Äôre working in teams.

In production repositories, teams often split workflows. For example: `deploy.yml` for deployments, `ci.yml` for tests, and `pochi.yml` for the AI assistant engine. This helps to tweak automation triggers without touching the core runner. Further, this also helps with modularity. Suppose later you want two flavours of auto-comments (e.g one for PRs and one for weekly crosn). Having them as separate workflows means you can enable / disable independently.

![Structuring workflows](./images/structuring-workflows.png)

That being said, you can always merge them into your existing `pochi.yml` file. However, combining everything into one file can become messy. Since GitHub Actions doesn‚Äôt support dynamic inline comment bodies well, the multi-file approach is cleaner and aligns better with common team practices.

### Custom GitHub Tokens (PAT)

When you create the new `.github/workflows/pochi-auto-comments.yml` workflow, the bot will automatically post a `/pochi summarize this PR` comment on your pull request. However, Pochi won‚Äôt respond to it. This is because GitHub has built-in protections: comments made by `github-actions[bot]` (the default Actions identity) do not trigger new workflows. This is done to prevent infinite workflow loops.

The solution is to use Personal Access Token (PAT) so the auto-comments come from your account instead of `github-actions[bot]`, mimicking as if you commented yourself like we did in Use Case 1. GitHub treats these PAT-authored comments as real user events which trigger workflows normally.

### Set Up the PAT

Now to setup your custom GitHub token, head over to to GitHub ‚Üí Settings ‚Üí Developer Settings ‚Üí Personal Access Tokens ‚Üí Tokens (classic). Here you need to click on Generate new token (classic).

When generating the token, check the following scopes:

* `repo` ‚Üí needed to comment on PRs/issues in your repos.
* `workflow` ‚Üí needed if you later chain workflows.

Click on Generate and copy the token.

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/16qhfQOnlCT_UVppU-jhYRe96BvLEquYS/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Pochi fix code"
  />
</div>

Then, in your repository, go to Settings ‚Üí Secrets ‚Üí Actions ‚Üí New repository secret. Name the secret `CUSTOM_GITHUB_TOKEN` and paste your PAT as the value.

### Add Auto-Comment Workflow

Now we‚Äôll create the `auto-comments.yml` file.  Click the 'Add file' button  and 'Create new file'.
Set the file path to: `.github/workflows/pochi-auto-comments.yml`:

Now paste in this YAML:

```yaml
name: Pochi Auto-Comments

on:
  pull_request:
    types: [opened]
  push:
    branches: [main]
  issues:
    types: [opened]

permissions:
  issues: write
  pull-requests: write
  contents: write

jobs:
  pr_auto_summary:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Auto-comment for PR summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CUSTOM_GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: "/pochi summarize this PR. Provide a high-level overview, key changes, risks, and what to test. (auto-triggered)"
            });

  push_commit_summary:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - name: Auto-comment for Commit Summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CUSTOM_GITHUB_TOKEN }}
          script: |
            const commits = context.payload.commits.map(c => `- ${c.message}`).join("\n");
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: 1, // optional: always-open tracking issue
              body: `/pochi summarize these commits:\n\n${commits}`
            });

```

The `pochi.yml` workflow (from Use Case 1) still listens for `/pochi` comments. Now, `pochi-auto-comments.yml` automatically posts those comments in response to events. To test this out, we‚Äôll make two tiny changes so the PR summary looks legit.

Navigate to your `src/server.ts` and edit the code by adding the following to your existing routes:

```javascript
app.get("/health", (_req, res) => {
  res.status(200).json({ ok: true });
});
```

We‚Äôll also make a tiny UI change on the frontend side. In your `src/components/UserList.tsx` file change the heading so there‚Äôs a visible diff:

```javascript
<h2>Users (auto-summary demo)</h2>
```

Now you can propose the changes as a PR.

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1ajCZRuYQZ6K3IQcCWf5ItJ3Hi9qy2UGl/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Summarize PR with PAT token"
  />
</div>

As you can see Pochi summarises the changes for us. We can further extend this workflow's capabilities by adding a new job that can issue design / architectural notes for any new issue that is created in your repository. To do that, add the following to your  `auto-comments.yml` file.

```yaml
issue_design_note:
    if: github.event_name == 'issues'
    runs-on: ubuntu-latest
    steps:
      - name: Auto-comment for Issue design note
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CUSTOM_GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: "/pochi draft design notes for this issue. Break down problem, options, acceptance criteria, and edge cases. (auto-triggered)"
            });
```

When you create a new issue Pochi, fill in your title and description, being as clear as possible and Pochi will comment out draft design notes to help you with your implementation.  Below is a example execution:

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1TRnTrUtRBwfpFAVB5x71ft-Vw2JmQj6A/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Issue design suggestions"
  />
</div>

At this stage, Pochi no longer needs you to type out commands. It can react automatically to PRs, commits, and issues, acting like a proactive AI teammate.

## Use Case 3: Pochi as Your CI/CD Gatekeeper

Now, we‚Äôll work towards how Pochi can go from just commenting to actually driving workflows. We‚Äôll make Pochi review a PR and identify if it needs changes. If yes, Pochi stops the workflow and addresses the user to implement the feedback. On the other hand, if everything looks good, Pochi lets the pipeline continue after approval.

This means you can run:

* **Conditional CI tests:** Unit tests (Jest, Mocha, Vitest), Integration tests (Cypress, Playwright, Postman) or Linting & type checks (ESLint, TypeScript, Prettier).
* **Conditional Deployments:** Frontend (Vercel, Netlify, GitHub Pages), Backend / APIs (AWS (EC2, ECS, Lambda)) or Internal systems (Helm/Kubernetes, Terraform pipelines).

For the purpose of this demo, we‚Äôd just run a sample `run_tests` job and for deployment we‚Äôll just print out ‚ÄúDeploying application‚Ä¶.‚Äù. But you can wire it up easily for your production-ready workflows too.

To get started, you can update your `.github/workflows/pochi.yml` YAML file. Paste in the following:

```yaml
name: Pochi Manual Reviewer

on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  pochi_review:
    if: startsWith(github.event.comment.body, '/pochi')
    runs-on: ubuntu-latest
    outputs:
      approved: ${{ steps.decide.outputs.approved }}
      decision: ${{ steps.decide.outputs.decision }}
    steps:
      - uses: actions/checkout@v4

      - name: Run Pochi
        id: run_pochi
        uses: tabbyml/pochi/packages/github-action@main
        env:
          POCHI_API_KEY: ${{ secrets.POCHI_API_KEY }}
        # You can pass an explicit instruction if you want:
        # with:
        #   args: "review this PR in detail. At the end, on the last line only, output exactly one of: ‚úÖ APPROVED or ‚ùå CHANGES_REQUIRED"

      - name: Decide from Pochi's final comment (‚úÖ or ‚ùå)
        id: decide
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.issue.number;

            function pickDecision(body) {
              if (!body) return null;
              if (body.includes('‚úÖ APPROVED')) return 'APPROVED';
              if (body.includes('‚ùå CHANGES_REQUIRED') || body.includes('‚ùå')) return 'CHANGES_REQUIRED';
              return null;
            }

            let decision = null;

            // Poll up to ~60s to let Pochi post its final result comment
            for (let i = 0; i < 12; i++) {
              const { data: comments } = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number,
                per_page: 50,
              });

              // Look newest to oldest
              for (const c of comments.slice().reverse()) {
                const d = pickDecision(c.body);
                if (d) { decision = d; break; }
              }

              if (decision) break;
              await new Promise(r => setTimeout(r, 5000));
            }

            core.info(`Pochi decision found: ${decision || 'NONE'}`);
            core.setOutput('decision', decision || 'NONE');
            core.setOutput('approved', decision === 'APPROVED' ? 'true' : 'false');

      - name: Show decision
        run: |
          echo "Decision: ${{ steps.decide.outputs.decision }}"
          echo "Approved: ${{ steps.decide.outputs.approved }}"

  run_tests:
    needs: pochi_review
    if: needs.pochi_review.outputs.approved == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: echo "‚úÖ Running tests..."; exit 0
      # replace the line above with: npm ci && npm test

  deploy:
    needs: run_tests
    if: success()
    runs-on: ubuntu-latest
    steps:
      - run: echo "üöÄ Deploying application..."
      # replace with your real deploy steps

  # OPTIONAL: make the workflow fail red when not approved
  reject_status:
    needs: pochi_review
    if: needs.pochi_review.outputs.approved != 'true'
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Pochi did not approve (decision=${{ needs.pochi_review.outputs.decision }}). Failing this run."
          exit 1

```

When you comment Pochi to review the code, if Pochi approves (‚úÖ no blocking issues), then CI will continue and run tests. If tests pass, deploy. But if Pochi flags issues (‚ùå), the workflow stops before tests/deploy.

To test this out, you can deliberately make the first PR bad (poor error handling, no validation, wrong status codes). This will showcase how the pipeline is blocked when Pochi flags the pull request as ‚Äú‚ùå Changes Required‚Äù.

Then you can submit a second PR with fixes (clean REST API, good status codes, input validation) and observe how Pochi approves it with ‚Äú‚úÖ Approved‚Äù and runs tests and deploys. Here are sample versions of a bad PR and a good PR.

### First PR (Bad version)

Update `src/server.ts`:

```javascript
import express from "express";

const app = express();
app.use(express.json());

let tasks: any[] = [];

// Add task (no validation, wrong status code)
app.post("/tasks", (req, res) => {
  tasks.push(req.body);
  res.send("Task added");
});

// Get tasks (no error handling, returns raw array)
app.get("/tasks", (req, res) => {
  res.send(tasks);
});

// Delete task (no validation, no proper status code)
app.delete("/tasks/:id", (req, res) => {
  const id = parseInt(req.params.id);
  tasks = tasks.filter((t: any, i: number) => i !== id);
  res.send("Deleted");
});

app.listen(3000, () => {
  console.log("Server running on http://localhost:3000");
});
```

Issues Pochi should flag:

* No validation for task data.
* Uses index as ID (not stable).
* No error handling (what if id doesn‚Äôt exist?).
* Always returns `200` with strings, not JSON.

### Second PR (Fixed version)

Update `src/server.ts`:

```javascript
import express from "express";

const app = express();
app.use(express.json());

interface Task {
  id: number;
  title: string;
  completed: boolean;
}

let tasks: Task[] = [];
let idCounter = 1;

// Adds task with validation and proper response formatting
app.post("/tasks", (req, res) => {
  const { title } = req.body;
  if (!title) {
    return res.status(400).json({ error: "Title is required" });
  }

  const newTask: Task = { id: idCounter++, title, completed: false };
  tasks.push(newTask);
  res.status(201).json(newTask);
});

// Get tasks (returns JSON)
app.get("/tasks", (req, res) => {
  res.json(tasks);
});

// Delete task with validation
app.delete("/tasks/:id", (req, res) => {
  const id = parseInt(req.params.id);
  const index = tasks.findIndex((t) => t.id === id);

  if (index === -1) {
    return res.status(404).json({ error: "Task not found" });
  }

  const deleted = tasks.splice(index, 1);
  res.json({ deleted: deleted[0] });
});

app.listen(3000, () => {
  console.log("Server running on http://localhost:3000");
});
```

**Note:** You‚Äôll temporarily need to comment out your `pochi-auto-comments.yml` file while doing Use Case 3. Otherwise, both workflows may run simultaneously and interfere with each other.

To test this out, once you open a PR, you need to comment:

```bash
/pochi review this PR in detail. At the end, on the last line only, output exactly one of: ‚úÖ APPROVED or ‚ùå CHANGES_REQUIRED
```

We ran this workflow on a sample task management project. The demo below is the part where changes were required:

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1crpQAKkx1e0LjfVwgDayOVFr1hSeL7Us/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Gatekeeper failed"
  />
</div>

Here is a demo showing when changes were approved:

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1aM8GD9qNmoBWV4R0RLgY8TRUYRwW2VQq/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Gatekeeper passed"
  />
</div>

This demonstration showcased how Pochi integrates directly into your CI/CD. It doesn't just review your PRs, it also acts as a gatekeeper, determining whether your code can proceed through the pipeline. You can easily wire this into your existing test suites and deployment targets.

An example enhancement could include chaining in extra jobs like notifications on top of tests and deploys. You can integrate with any API-based tool your team uses, like Linear, Jira, Datadog, PagerDuty, or others. Pochi becomes the gatekeeper, and the rest of the pipeline is up to you.

## Use Case 4: Enforce Team Coding Rules

Next, let‚Äôs look at team-based use cases. In large organisations, developers often have to follow team‚Äôs specific coding rules instead of just generic best practices. You can take the learnings from this tutorial so far and create a `.md` file that holds your team coding standard / review ruleset.

Here‚Äôs a sample `POCHI.md` you can start with:

```markdown

# POCHI Review Guidelines

Pochi must follow these project-specific rules when reviewing code:

## General Standards
-  All code must use **TypeScript** (no plain JS allowed).
-  Use **ESLint** conventions (semi-colons required, no unused vars).
-  Ensure functions are small, focused, and named descriptively.
-  Always include **error handling** for async operations.
-  API endpoints must return **proper HTTP status codes** and JSON responses.

## Backend Standards
-  Express routes must validate inputs using middleware or explicit checks.
-  No use of `any` type ‚Äî define proper interfaces.
-  Business logic must be separated from route handlers.

## Frontend Standards
-  React components must be functional, not class-based.
-  Use hooks (`useState`, `useEffect`) instead of lifecycle methods.
-  Separate UI from business logic ‚Äî no API calls directly inside components (use services/hooks).
-  Components must include **basic prop validation**.

## Git & Workflow Standards
-  PRs must include a **descriptive title** and summary of changes.
-  PRs must not bundle unrelated changes (e.g., workflow + backend + frontend in one PR).
-  README.md must be updated if functionality changes.

At the end of each review, Pochi must enforce these rules and output exactly one of:
- ‚úÖ APPROVED (if all standards are met)
- ‚ùå CHANGES_REQUIRED (if any rules are broken)

```

In your `.github/workflows/pochi.yml`, tweak the `args` line:

```bash
with:
  args: "review this PR according to POCHI.md. At the end, on the last line only, output exactly one of: ‚úÖ APPROVED or ‚ùå CHANGES_REQUIRED"

```

Now every time you run `/pochi`, it will read your repository‚Äôs `POCHI.md` and enforce those rules in its review.

You can also test out any PR by commenting:

```bash
/pochi review this PR according to POCHI.md
```

## Use Case 5: Schedule Background Jobs (CRON)

We‚Äôll now add CRON jobs in GitHub Actions to call Pochi automatically. This means Pochi can also run on its own schedule, like a background agent in your repository. You can ask it to draft weekly release notes by updating the `CHANGELOG.md` file, schedule dependency and security reviews, or scan your repo for code that needs attention.

We can showcase this with a small demo. Let‚Äôs create a simple `pochi-cron.yml `file.

```yaml
name: Pochi Continuous Agent

on:
  workflow_dispatch:   # manual trigger for demo
  schedule:
    - cron: "0 0 * * *"    # nightly at midnight UTC

permissions:
  contents: write
  issues: write

jobs:
  nightly_todo_scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Scan TODOs and create issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");
            const path = require("path");

            // simple recursive scan
            function walk(dir, filelist = []) {
              fs.readdirSync(dir).forEach(file => {
                const filepath = path.join(dir, file);
                if (fs.statSync(filepath).isDirectory()) {
                  filelist = walk(filepath, filelist);
                } else if (/\.(ts|tsx|js|jsx)$/.test(file)) {
                  filelist.push(filepath);
                }
              });
              return filelist;
            }

            const files = walk("src");

            for (const file of files) {
              const lines = fs.readFileSync(file, "utf-8").split("\n");
              lines.forEach((line, i) => {
                if (line.includes("TODO") || line.includes("FIXME")) {
                  github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: `TODO in ${file}:${i + 1}`,
                    body: `Found in \`${file}\` line ${i + 1}:\n\n${line.trim()}`
                  });
                }
              });
            }

```

Now, add some `// TODO: improve validation` lines in `src/server.ts`. Commit the code, then go to Actions ‚Üí Pochi Continuous Agent ‚Üí Run workflow. You‚Äôll see Pochi create new issues from the TODOs it scanned in your codebase.

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1UkJJq9Pmx-Kz8EBnQGdGUo_Bd4HbPAYC/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Cron job"
  />
</div>

Although we triggered it manually for the demo, Pochi can run automatically without waiting for a command. It can proactively maintain the repository by acting as a continuous background agent.

You can also have it draft weekly release notes by adding a new job to your `pochi-cron.yml` file. For example:

```yaml
  weekly_release_notes:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Pochi Draft Release Notes
        uses: tabbyml/pochi/packages/github-action@main
        env:
          POCHI_API_KEY: ${{ secrets.POCHI_API_KEY }}
        with:
          args: |
            Summarize changes since last Monday into draft release notes.
            Append them to CHANGELOG.md under a new "## Weekly Draft (YYYY-MM-DD)" heading.
            Commit the file back to the repo.

```

## Enterprise Scaling - Power Up Your Pochi

So far, we‚Äôve seen how Pochi can help as a reviewer, gatekeeper and improve productivity across teams and developers. Now we‚Äôll talk about Pochi in enterprise environments where speed, control, and cost play an even bigger role. Let‚Äôs have a look at how Pochi can run anywhere with custom models, custom tokens and custom runners.

### Custom Models

Enterprises can select their preferred LLM backend for reviews by configuring it like this:

```yaml
env:
  POCHI_API_KEY: ${{ secrets.POCHI_API_KEY }}
  POCHI_MODEL: claude-3-sonnet   # or gemini-1.5-pro, gpt-4o, etc.
```

This gives control, as teams prefer different models, sometimes many models across different tasks. This flexibility is useful because some models excel at code generation, while others perform better at logical reasoning, making them ideal for code reviews.

### Custom Tokens

We saw in Use Case 2, how we created a custom GitHub token (PAT) to mimic user-authored comments, allowing us to maintain GitHub‚Äôs built-in protections and avoid infinite workflow loops. This is how enterprises in production codebases grant Pochi extra permissions safely.

### Custom Runners

Unlike tools that lock you into proprietary infrastructure, Pochi is flexible. You can run it on:

* **GitHub‚Äôs default runners:** They run on `ubuntu-latest`, are slower, but simple. The cost gets included in GitHub Actions minutes.
* **Self-hosted runners (your infra):** They run on `self-hosted`. You bring your own VM/metal (AWS, GCP, on-prem). This offers advantages in speed and privacy, while helping meet compliance requirements like SOC 2, HIPAA, and GDPR.
* **Third-party accelerated runners (e.g., Depot, WarpBuild, etc.):** This is optimized hardware (faster CPUs, RAM disks, lower cold-start time). These options offer cheaper and faster runs than GitHub-hosted runners, with less operational overhead than fully self-hosted setups.

```yaml
jobs:
  pochi_review:
    # Default: GitHub-hosted
    runs-on: ubuntu-latest

    # Enterprise option: run inside your own infra
    # runs-on: self-hosted

    # Performance option: run on an optimized runner (e.g., Depot)
    # runs-on: depot-ubuntu-latest
```

This design is enterprise-friendly and cost-effective, giving teams the flexibility to choose based on their performance, cost, and compliance needs.

## Troubleshooting

If you‚Äôre just starting out and Pochi doesn‚Äôt respond the first time, here are a few common issues and their fixes.

#### Response failure:

* Check your workflow trigger to see if the `on: issue_comment` is set.
* Check if your `startsWith(github.event.comment.body, '/pochi‚Äô)` matches your comment exactly.
* And lastly, your secret should be named exactly `POCHI_API_KEY`.

#### Auto-Comments failure:

* In most cases, it is permission issues. Make sure you granted issues: write and pull-requests: write permissions in your workflow.

#### Push/commit failure:

* This is also likely a permissions issue.. You should have `contents: write`.
* Or you may need a \[Personal Access Token (PAT)] instead of the default `GITHUB_TOKEN`.

#### Integration tools issues:

* Test your secret first with a simple `echo` (it should show as \*\*\* masked in logs).
* Then run a basic curl command with the webhook URL to confirm if it works.

## Conclusion

We started this tutorial with a basic GitHub Actions workflow where Pochi reviewed pull requests on command. As we progressed through each use case, we extended it into something more powerful that could gatekeeper PRs, enforce custom rules and handle routine tasks in the background.

This is the true power, where we just didn‚Äôt automate pipelines, but extended them with intelligence using Pochi. And because Pochi lives inside GitHub Actions, it integrates with the tools and workflows your team already uses.

Try adding Pochi to your repository today with just one YAML file, and see how quickly it becomes part of your team.


# Build a Custom MCP Server to Query Supabase
URL: /tutorials/supabase-mcp-server
Build a custom MCP server in Pochi that lets you run natural language SQL queries on your Supabase database.
***

title: 'Build a Custom MCP Server to Query Supabase'
description: "Build a custom MCP server in Pochi that lets you run natural language SQL queries on your Supabase database."
image: "/og-image/mcp-server-supabase-og-image.png"
---------------------------------------------------

# Build a Custom MCP Server to Query Supabase

In this tutorial, you‚Äôll learn how to build a custom MCP server in Pochi that lets you run natural language SQL queries on your Supabase database. This lets you query your database directly from your code editor using everyday language, making complex SQL queries simple and intuitive.

This is a practical example of extending Pochi using the Model Context Protocol (MCP), and illustrates how teams can integrate AI into internal workflows for powerful, context-aware automation. This is particularly useful when you're debugging code, collaborating across teams, or building features that require quick access to live data (e.g: checking whether a migration seeded correctly, inspecting a table schema, or verifying specific column values).

### Prerequisites

Before we start, you‚Äôll need the following:

* **[Install Pochi](https://docs.getpochi.com/#installation)**
* **[Setup a Supabase Project](https://supabase.com/dashboard/)**
* **[OpenAI API Key](https://platform.openai.com/)**  (You can use any other LLM model if preferred.)

## What is MCP (Model Context Protocol)?

MCP (Model Context Protocol) is a lightweight, flexible interface that allows large language models (LLMs) like those used in Pochi to connect and interact with external tools, APIs, or databases. In this tutorial, **[MCP](https://docs.getpochi.com/mcp/)** acts as the bridge between your natural language queries and the Supabase database, enabling Pochi to translate plain English questions into SQL queries using OpenAI, execute them, and even generate visualizations using Vega Charts.

![Architectural Diagram](./images/mcp-server-supabase-diagram.png)

We‚Äôre going to use Supabase database and limit to read only queries, but you can always extend to perform CRUD operations too. Using MCP servers makes it easy to extend AI assistants with custom functionality and is a perfect way to keep your focus on coding while still getting the data context you need.

## Getting Started: How to Build the MCP Server

### Step 1: Setup your VS Code project

First, we‚Äôll set up a new project inside VS Code. To do so, we‚Äôll create a new folder and initialise a Node project.

```bash
mkdir supabase-mcp-server
cd supabase-mcp-server
npm init -y
```

The command `npm init -y` quickly creates a `package.json` file in your project directory using default values, without prompting you for configuration.

Once the project is setup, we need to install the required dependencies.¬†Run the following command:

```bash
npm install @modelcontextprotocol/sdk zod openai dotenv @supabase/supabase-js
```

* `@modelcontextprotocol/sdk` ‚Äì Provides tools to manage structured context and memory for LLMs.
* `zod` ‚Äì Required to define schemas for input/output in the MCP SDK.
* `openai` ‚Äì Used to interact with OpenAI‚Äôs language and image models.
* `dotenv` ‚Äì Loads environment variables from a .env file into the app.
* `@supabase/supabase-js` ‚Äì Enables database, auth, and storage operations with Supabase.

### Create a `.env` file

The `.env` file is created to store your Supabase and OpenAI keys to avoid exposing them on the code side. You can fetch your Supabase API key by going to Settings -> API keys and creating a secret service role API key.
![API Keys Supabase Dashboard](./images/api-keys-supabase-dashboard.png)

For the OpenAI key, go to your **[dashboard and API keys](https://platform.openai.com/settings/organization/api-keys)** section where you can click `+Create a secret key` button on the top right corner.
![OpenAI Dashboard](./images/openai-dashboard.png)

Paste these keys in the `.env` file as follows:

```jsonc
SUPABASE_URL=your-project-url
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
OPENAI_API_KEY=your-openai-api-key
```

### Step 2: Create your Supabase Database

You can create a database table by going to Database -> Tables -> New Table. Add the relevant `Name`, `Description` and `Column` types you want or import via a CSV.

![Create Supabase Table](./images/create-supabase-table.png)

What we‚Äôll do here instead is to open the SQL editor and create a database by running the below query:

```sql
CREATE TABLE IF NOT EXISTS sales_data (
    id UUID PRIMARY KEY,
    sale_date DATE NOT NULL,
    region TEXT NOT NULL,
    product TEXT NOT NULL,
    sales_amount NUMERIC(12,2) NOT NULL,
    quantity INTEGER NOT NULL
);
```

This creates a `sales_data` table with columns for `id`, `sale_date`, `region`, `product`, `sales_amount`, and `quantity`. To insert values into this database you can again do it manually, or via SQL insertion as below:

```sql
INSERT INTO sales_data (id, sale_date, region, product, sales_amount, quantity) VALUES
('550e8400-e29b-41d4-a716-446655440000', '2024-01-01', 'North America', 'Smartphone', 120345.50, 350),
('550e8400-e29b-41d4-a716-446655440048', '2024-01-02', 'Europe', 'Laptop', 98000.00, 220),
('550e8400-e29b-41d4-a716-446655440003', '2024-01-03', 'Asia', 'Tablet', 45000.75, 180),
('550e8400-e29b-41d4-a716-446655440004', '2024-01-04', 'South America', 'Smartwatch', 25000.00, 90),
(Include the rest of your rows here)
```

This is how your database table will look:
![Final Supabase Table](./images/table-final-supabase.png)

### Step 3: Prompt Pochi to build out the MCP server & Supabase Client

You can generate your MCP server in minutes by prompting Pochi to create the required files. Here‚Äôs a prompt you can use:

```
Create a new project for an MCP server that connects to Supabase. I need three files:
- `supabaseClient.js` for initializing the Supabase client using environment variables
- `index.js` for the MCP server with a queryDatabase tool that takes a plain-English question, translates it into SQL with OpenAI, runs it on Supabase, and outputs results and a Vega-Lite chart
- `.env` showing what env vars are needed.‚Äù

Transport
- Use `StdioServerTransport` from MCP SDK.
- The server must run as a subprocess and communicate with Pochi/Inspector via stdio.

Error Handling
- Always return `success: true|false`.
- On error, return `{ success: false, rows: [], error: "<message>" }`.

```

Here‚Äôs the generated `supabaseClient.js` file:

```javascript
import { createClient } from "@supabase/supabase-js";
import dotenv from "dotenv";

dotenv.config();

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseKey) {
  console.error("‚ùå Missing SUPABASE_SERVICE_ROLE_KEY env var");
  throw new Error("SUPABASE_SERVICE_ROLE_KEY environment variable is required");
}

export const supabase = createClient(supabaseUrl, supabaseKey, {
  auth: { persistSession: false, autoRefreshToken: false },
  global: {
    headers: { "User-Agent": "mcp-supabase-server/1.0.0" },
  },
});
```

**Note:** Pochi comes with built-in support for various LLM providers. This grants flexibility, as not every model behaves the same way. Some are ideal for code generation, while some do logical reasoning better and often switching models is enough to break out of an error loop you might be stuck in.

There is also the option to ‚ÄúBring Your Own Key‚Äù (BYOK), if you‚Äôre working on large codebases with a team that requires unlimited usage, wants to log and bill everything in their own OpenAI account, or if you need access to models beyond what Pochi provides by default. For this tutorial, we‚Äôll stick with the default setup but you can read more about this **[here](https://docs.getpochi.com/models/)**.

![BYOK or use supported models](./images/byok-pochi.png)

Also, It‚Äôs important to define your database schema in order for OpenAI to create the proper SQL queries. Otherwise, the SQL generated will keep referencing new table and column names which would fail with ‚ÄúNo \[database / column name] found" since they don‚Äôt exist.

In your prompt to Pochi you can define the database schema as such:

```
You must ONLY use this schema:
Table: sales_data
- id (uuid)
- sale_date (date)
- region (text)
- product (text)
- sales_amount (numeric)
- quantity (integer)
```

Here‚Äôs the complete `index.js` file that was generated:

````javascript
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { supabase } from "./supabaseClient.js";
import { z } from "zod";
import OpenAI from "openai";
import dotenv from "dotenv";

dotenv.config();

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Known schema description (from your DB)
const schemaDescription = `
You must ONLY use this schema:
Table: sales_data
- id (uuid)
- sale_date (date)
- region (text)
- product (text)
- sales_amount (numeric)
- quantity (integer)
`;

// Helper: build Vega-Lite spec automatically
function buildVegaLiteSpec(rows) {
  if (!rows || rows.length === 0) return null;
  const sample = rows[0];
  const keys = Object.keys(sample);

  let xKey = keys.find(
    (k) =>
      typeof sample[k] === "string" ||
      k.toLowerCase().includes("date") ||
      k.toLowerCase().includes("region") ||
      k.toLowerCase().includes("product")
  );
  let yKey = keys.find(
    (k) =>
      typeof sample[k] === "number" ||
      k.toLowerCase().includes("amount") ||
      k.toLowerCase().includes("quantity") ||
      k.toLowerCase().includes("total")
  );

  if (!xKey || !yKey) return null;

  return {
    $schema: "https://vega.github.io/schema/vega-lite/v5.json",
    description: `Auto-generated chart of ${yKey} by ${xKey}`,
    data: { values: rows },
    mark: "bar",
    encoding: {
      x: { field: xKey, type: "ordinal" },
      y: { field: yKey, type: "quantitative" },
    },
  };
}

// Create MCP server
const server = new McpServer({
  name: "supabase-mcp",
  version: "1.0.0",
});

// Tool: queryDatabase (Plain English ‚Üí SQL ‚Üí Supabase)
server.tool(
  "queryDatabase",
  {
    inputSchema: z.union([
      z.string(), // tolerate CLI sending plain string
      z.object({ question: z.string() }), // VS Code sends {question: "..."}
    ]),
    outputSchema: z.any(), // tolerate CLI sending "{}" as a string
  },
  async (input) => {
    try {
      let question = "";

      // üîë Normalize input from different runtimes
      if (typeof input === "string") {
        question = input;
      } else if (input?.question) {
        question = input.question;
      } else if (typeof input?.inputSchema === "string") {
        try {
          const parsed = JSON.parse(input.inputSchema);
          if (parsed.question) question = parsed.question;
        } catch {
          // ignore parse errors
        }
      } else if (input?.inputSchema?.question) {
        question = input.inputSchema.question;
      }

      if (!question.trim()) {
        return { success: false, rows: [], error: "No question provided" };
      }

      // üöÄ Translate English ‚Üí SQL
      const completion = await openai.chat.completions.create({
        model: "gpt-4.1",
        messages: [
          {
            role: "system",
            content: `You are an assistant that translates plain English into SQL queries for PostgreSQL.
${schemaDescription}
‚ö†Ô∏è Important: Only use the table and columns listed above. Never invent names.`,
          },
          { role: "user", content: question },
        ],
        temperature: 0,
      });

      const sqlRaw = completion.choices[0].message.content.trim();
      console.error("Generated SQL (raw):", sqlRaw);

      const sqlMatch = sqlRaw.match(/```(?:sql)?\s*([\s\S]*?)\s*```/i);
      const sql = (sqlMatch ? sqlMatch[1] : sqlRaw).replace(/;$/, "").trim();

      console.error("Final SQL:", sql);

      if (!/^select/i.test(sql)) {
        return {
          success: false,
          rows: [],
          error: "Generated SQL is not a SELECT statement",
          sql,
        };
      }

      const { data, error } = await supabase.rpc("exec_sql", {
        sql_query: sql,
      });

      if (error) {
        return {
          success: false,
          rows: [],
          error: `SQL execution failed: ${error.message}`,
          sql,
        };
      }

      const rows = Array.isArray(data) ? data : [];
      const vega = buildVegaLiteSpec(rows);

      const content = vega
        ? [
            {
              type: "chart",
              format: "vega-lite",
              data: vega,
            },
          ]
        : [];

      return { success: true, rows, vega, content, sql };
    } catch (err) {
      return {
        success: false,
        rows: [],
        error: String(err.message || err),
      };
    }
  }
);

// Transport
const transport = new StdioServerTransport();

// Connect the server and handle potential errors
server.connect(transport).catch((error) => {
  console.error("Connection error:", error);
  process.exit(1);
});

process.on("SIGINT", () => process.exit(0));
process.on("SIGTERM", () => process.exit(0));

console.error("‚úÖ Supabase MCP server running (STDIO, NL ‚Üí SQL enabled)");
````

#### Writing the `exec_sql` function

In the `index.js` file, you‚Äôd notice the following code:

```jsonc
const { data, error } = await supabase.rpc("exec_sql", { sql_query });
```

This allows your MCP server to send queries to Supabase. When the server calls the code above, it sends your generated SQL string to the `exec_sql` function in Supabase, which executes it on the server and returns the results as JSON

Now, Supabase does not support executing SQL directly through the client SDK. To make this work, we need to create an `exec_sql` RPC function in Supabase editor. Here‚Äôs the code you need to execute:

```sql
create or replace function exec_sql(sql text)
returns setof json as $$
begin
  return query execute sql;
end;
$$ language plpgsql;
```

![Exectue RPC function](./images/exec-function-supabase-dashboard.png)

### Step 4: Configure Pochi to add your MCP server config

In your VS Code, press `Command + Shift + P` on Mac, or `Ctrl + Shift + P` on Windows and open the `Pochi: Open MCP Server Settings`. Here, you need to add your MCP server config. Initially it is empty:

```jsonc
‚Äúmcp": {}
```

Paste this JSON snippet inside the existing MCP config :

```jsonc
"mcp": {
    "my-supabase-mcp": {
      "command": "/Users/apple/.nvm/versions/node/v20.19.0/bin/node",
      "args": [
        "index.js"
      ],
      "cwd": "/Users/apple/Documents/supabase-mcp-server"
    }
  }
```

The above code snippet will register a local MCP server in Pochi.

* `command` = This is the path to the Node.js executable you want to use.
* `args` = The actual MCP server package or script to run (which we will generate in Step 6)
* `cwd` = The current working directory where the command will run.

When you save this config in the `~/config.json` file, Pochi will know to launch `node index.js` as a subprocess and communicate with it via stdio transport when the ‚Äúmy-supabase-mcp‚Äù server is enabled. Read more about it **[here](https://docs.getpochi.com/mcp/)**.

### Step 5: Testing the MCP Server

Now that our server is created, we can test it using the MCP Inspector. The inspector is a way to verify the tools and resources exposed by the server work as expected. To do that first we install the MCP Inspector

```bash
npm install @modelcontextprotocol/inspector
```

Then you need to run  your MCP server in Inspector:

```bash
npx @modelcontextprotocol/inspector node index.js
```

(make sure you‚Äôre in your project folder, in this case: `supabase-mcp-server`).

Open the Inspector in your browser (it launches a local port).

* You‚Äôll see a UI showing your server name (\`supabase-mcp\`\`).
* Under ‚ÄúTools‚Äù you should see \`querySupabaseSQL\`\`.
* Click it, pass in your input:

```jsonc
{"question":"What are the total sales of each product by region?"}
```

You should see the correct response which includes the Supabase database query result and a Vega Lite JSON spec.

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1tqM2tglxVkw3gNUR0TYJiPWgOmfezS1d/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Testing MCP Server in MCP Inspector"
  />
</div>

#### Enable your MCP server

Now that your MCP server is verified, you can enable it inside Pochi to use it in your editor‚Äôs natural language chat UI. For that, we need to go to Pochi‚Äôs Tools Settings page (you can also find it via Command Palette: `Pochi: Open Tools Settings`)

Look for the MCP server named `my-supabase-mcp` and toggle it ON (enabled). You should see a green dot to indicate its connected.

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1txzxWQ5R0fRZVSme1UtCRb77WguU0O6H/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Enable MCP Server in Pochi"
  />
</div>

### Step 6: Executing the MCP server in Pochi

Once it works in Inspector, we can connect it into Pochi (our config already points to `index.js`). Then when you give Pochi a natural language prompt,  asking the model to call `queryDatabase` tool, it will answer all your database related queries easily.

Prompt used:

> Use the `queryDatabase` tool to find out what are the total sales for each product by region

Here‚Äôs the final working demo:

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1enHFWwNik28f8oWMKtMY5QVCuMd7lbSZ/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Executing MCP Server in Pochi"
  />
</div>

You can also paste in the Vega - Lite JSON spec you receive in response into the Vega Editor and get a chart response of the requested query:

![Vega Lite Chart](./images/vega-chart-final-image.png)

## Step 7 (Optional): Using the MCP Server with Pochi CLI

So far, we‚Äôve tested our Supabase MCP server in the Inspector, wired it into the Pochi VS Code extension, and also tested via the Pochi chat UI. But Pochi also provides a **[CLI client](https://docs.getpochi.com/cli/)** that can connect to MCP servers directly from your terminal.

This means you can query your database without opening VS Code at all:

```bash
pochi -p "What are the total sales for Europe region?"
```

Behind the scenes, the Pochi CLI works the same way as the VS Code extension: it connects to your MCP server via `stdio`, calls the `queryDatabas`e tool, and streams the results back into your terminal.

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1V8Ut_XXM9sRdSPHhoGVhMMnJHkxeaYFp/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Executing MCP server via CLI"
  />
</div>

Invoking via the CLI helps if you spend most of your time in the shell or on remote servers. It also works great over SSH, in Docker containers, or CI/CD pipelines where you don‚Äôt have an editor UI. Moreover, you can use in automation workflows by wrapping `pochi -p` commands in scripts to periodically check metrics.

## Conclusion: Improving Developer Workflow for Teams and Enterprises

Whether you're querying user logs, verifying migrations, or building internal dashboards, MCP lets you build custom servers that connect Pochi to your unique internal tools and workflows. This Supabase MCP server is just one example of how Pochi‚Äôs powerful extensibility can help your team stay in flow, access real-time context, and reduce the friction of internal data access.

Now that you‚Äôve seen what‚Äôs possible, here are a few ways to take your project further:

* **Deploy your MCP server with HTTP Transport**: Instead of running locally via stdio, you can deploy your server over HTTP. This enables multiple team members. from developers to engineering managers, to securely access the same database instance through Pochi, with proper access controls, rate limiting, and centralized schema management. **[Learn more](https://docs.getpochi.com/mcp/#remote-mcp-servers-http-transport)**
* **Expand beyond read-only queries**: This tutorial focused on read-only queries for simplicity, but you can extend your MCP server to support full CRUD operations, allowing your natural language interface to create, update, and delete records as well.
* **Customize and optimize prompts**: Experiment with prompt design for OpenAI to improve SQL accuracy or add support for additional data visualizations beyond Vega Lite charts.
* **Contribute and share**: If you built something cool or want to see tutorials on related topics, such as CRUD operations or deployment best practices, please reach out by using `/create-issue command` within the Pochi VS Code extension or **[contribute to the project](https://github.com/TabbyML/pochi?tab=contributing-ov-file)**!
