# Auto Compact
URL: /auto-compact
Reduce context usage by summarizing long conversations‚Äîinline or into a new task
***

title: "Auto Compact"
description: "Reduce context usage by summarizing long conversations‚Äîinline or into a new task"
icon: "ScanText"
----------------

# Auto Compact

Auto Compact helps you keep long conversations efficient by summarizing earlier messages when your token usage grows large. You can either:

* Compact in the current task (inject a compact summary so you can continue seamlessly)
* Start a new task with the summary (spawn a fresh task seeded with a concise recap)

![Auto Compact overview](../assets/images/auto-compact.png)

## When Auto Compact is available

Auto Compact becomes available from the token usage chip in the toolbar when all of the following are true:

* The conversation isn‚Äôt streaming or executing
* The chat isn‚Äôt read-only
* No other compact action is pending
* Total tokens ‚â• 50,000 (min threshold)

If the threshold isn‚Äôt met, you‚Äôll see a tooltip explaining that more tokens are required to compact.

While compacting, the chip shows a spinner with the ‚ÄúCompacting‚Äù label.

![Compacting in progress](../assets/images/auto-compacting.png)

## Two ways to compact

### Option A ‚Äî Compact in current task

Use this to stay in the same task. Pochi will:

1. Generate a concise summary of the conversation up to your latest message
2. Inject a compact block at the top of your last user message
3. Continue the conversation with the condensed context

> Notes: The summary is wrapped into a compact section and prepended to your last message to preserve intent while saving context.

### Option B ‚Äî Start new task with summary

Use this to branch a fresh task based on the current work. Pochi will:

1. Create a summary of the existing conversation
2. Open a new task seeded with the summary and a short handoff message
3. Navigate you to the new task to continue

![Inline compact summary in current task (expandable)](../assets/images/auto-compact-with-new-task-summery.png)

## Technical Details

* Trigger: You choose either ‚ÄúCompact task‚Äù (inline) or ‚ÄúNew task with summary‚Äù.
* Summary prompt: Pochi asks the model to produce a concise recap focused on key topics, decisions, and important context (limited to a few thousand tokens of output).
* Inline compact: The recap is wrapped in a compact block and prepended to your last user message before the next response.
* New task: The recap becomes the first message of a brand-new task, followed by a short instruction letting the agent analyze status and confirm next steps.
* Safety/availability: Buttons are disabled during streaming/execution, or when below the minimum token threshold.

## Tips

* Prefer inline compact when you want continuity within the same task.
* Use ‚Äúnew task with summary‚Äù to cleanly branch, hand over, or checkpoint work.
* You‚Äôll see a ‚ÄúCompacting‚Äù state while the summary is being generated‚Äîthis can take a moment for very long threads.


# Checkpoints
URL: /checkpoint

***

title: Checkpoints
icon: "Route"
-------------

# Checkpoints

Checkpoints automatically save a snapshot of your workspace after key steps in a task. They help you track changes, roll back when needed, and explore different implementations without worrying about breaking your code.

<div align="center">
  ![Checkpoint overview](../assets/images/checkpoint-overview.png)
</div>

## How checkpoints work

Pochi creates a checkpoint after important actions such as file edits or applied fixes. These checkpoints:

* Run alongside your Git workflow without interference
* Preserve the conversation context when restoring (chat and task context remain intact)
* Track file changes using a shadow Git repository (no writes to your real repository)

Example: while developing a feature, the assistant updates multiple files. Each change creates a checkpoint. You can review each modification, and if needed, roll back to any point without impacting your main branch or real Git history.

## Viewing changes and restoring

After each key action, you can:

1. Click Compare to see modified files and diffs
2. Click Restore to open restore options

<div align="center">
  ![Checkpoint compare](../assets/images/checkpoint-compare.png)
</div>

## Restore options

To go back to a previous point:

1. Click Restore next to any step
2. Choose how you want to restore:
   * Restore Workspace and Task (when available): revert both code and task context
   * Restore Task Only (when available): keep code changes, revert task context
   * Restore Workspace Only: revert code while preserving task context (current default)

Note: The current version focuses on ‚ÄúRestore Workspace Only.‚Äù Other options will appear as their capabilities are enabled.

<div align="center">
  ![Checkpoint restore options](../assets/images/checkpoints-restore.png)
</div>

## Under the hood

In VS Code, Pochi implements checkpoints with a shadow Git that stays separate from your real repository:

* Initializes a bare repository under the extension‚Äôs storage directory (scoped per workspace)
* Points the worktree to your workspace, then stages and commits changes into the shadow repo
* Excludes common large/binary/cache/build artifacts (see Exclusions) to keep things fast and stable

This shadow repo is fully independent. Saving or restoring checkpoints does not create commits in your actual Git repository.

## Requirements

* **Git** must be installed (the shadow Git depends on it). If Git isn‚Äôt available, the checkpoint feature can‚Äôt initialize and will be disabled.

## Smart detection and exclusions

Pochi automatically detects and excludes heavy or redundant files to keep checkpoints lean and fast, including:

* Build artifacts and dependency folders
* Media files and large binaries
* Cache, logs, and temporary files
* Environment configuration files
* Files tracked by Git LFS

With this smart filtering, checkpoints focus on core code changes‚Äîmaking diffs clearer and restores faster.


# CLI
URL: /cli
Pochi CLI allows you to run an AI agent directly from the command line.
***

title: CLI
description: Pochi CLI allows you to run an AI agent directly from the command line.
icon: "SquareTerminal"
----------------------

# CLI

Pochi offers a command-line interface (CLI) that allows you to run an AI agent directly from the command line.

## Oneliner Install

<Tabs items={['Curl', 'Homebrew', 'NPM']}>
  <Tab value="Curl">
    ```bash
    curl -fsSL https://getpochi.com/install.sh | bash
    ```
  </Tab>

  <Tab value="Homebrew">
    ```bash
    brew install tabbyml/pochi/pochi
    ```
  </Tab>

  <Tab value="NPM">
    ```bash
    npm install -g @getpochi/cli
    ```
  </Tab>
</Tabs>

## Authentication

The Pochi CLI uses the same authentication credentials as the VS Code extension for Pochi's cloud services. When you sign in through the VS Code extension, the CLI automatically reuses these credentials.

Credentials are stored in `~/.pochi/config.jsonc`. To authenticate:

1. Install and open the [Pochi VS Code extension](https://marketplace.visualstudio.com/items?itemName=TabbyML.pochi)
2. Follow the sign-in prompts in the extension
3. The CLI will automatically use the same credentials

For non-Pochi models, first configure it in your Pochi configuration file (`~/.pochi/config.jsonc`). See [Models documentation](./models.mdx) for details on how to configure custom providers.

Then you can use the model by specifying the provider and model ID separated by a slash:

```bash
pochi --model groq/llama3-8b-8192 -p "What is the time now?"
```

## Usage

You can pass a prompt to run a task:

```bash
pochi -p "What is the time now?"
```

Or pipe input as a prompt:

```bash
echo "What is the time now?" | pochi
```

For detailed usage instructions, run `pochi -h`, below is the output fom version 0.5.3

```
Usage: pochi [options]

Pochi v0.5.5

Prompt:
  -p, --prompt <prompt>   Create a new task with the given prompt. You can also
                          pipe input to use as a prompt, for example: `cat
                          .pochi/workflows/create-pr.md | pochi`. To use a
                          workflow, use /workflow-name, for example: `pochi -p
                          /create-pr`. Workflows can be embedded in larger
                          prompts, for example: `pochi -p "please /create-pr
                          with feat semantic convention"`

Options:
  --max-steps <number>    Maximum number of stepsto run the task. If the task
                          cannot be completed in this number of rounds, the
                          runner will stop. (default: 24)
  --max-retries <number>  Maximum number of retries to run the task in a single
                          step. (default: 3)

Model:
  --model <model>         The model to use for the task. (default:
                          "qwen/qwen3-coder")

Others:
  -V, --version           Print the version string.
  -h, --help              Print this help message.
```

## Debugging

To enable debug logging for the CLI, you can set the `POCHI_LOG` environment variable:

```bash
POCHI_LOG=debug pochi -p "What is the time now?"
```

This will output detailed logs about the CLI's operation, which can be helpful for troubleshooting issues.

For more granular control, you can specify log levels for specific components:

```bash
POCHI_LOG=Pochi=debug,TaskRunner=trace pochi -p "What is the time now?"
```


# Custom Agent
URL: /custom-agent
Learn how to create and use custom agents in Pochi.
***

title: Custom Agent
icon: Bot
description: Learn how to create and use custom agents in Pochi.
----------------------------------------------------------------

# Custom Agents

Pochi allows you to define custom agents to handle specific tasks. These agents can be tailored with their own system prompts and sets of tools, enabling you to create specialized assistants for your workflows.

## Defining a Custom Agent

Custom agents are defined in `.md` files located in either the project's `.pochi/agents/` directory or the system-wide `~/.pochi/agents/` directory.

An agent definition file consists of two parts: a frontmatter section for configuration and a content section for the system prompt.

Here is an example of a custom agent definition:

```markdown
---
description: Description of when this custom agent should be invoked
tools:
  - tool-1
  - tool-2
  - tool-3
---

Your custom agent's system prompt goes here. This can be multiple paragraphs
and should clearly define the custom agent's role, capabilities, and approach
to solving problems.

Include specific instructions, best practices, and any constraints
the custom agent should follow.
```

If the agent is saved as `my-agent.md` and the `name` attribute is omitted, `my-agent` will be used as the agent name.

### Configuration

The frontmatter provides metadata for the custom agent:

* `name` (optional): A unique name for your agent. If omitted, the filename (without the extension) is used as the name.
* `description` (required): A short description of what the agent does. This is used to help Pochi decide when to use your agent.
* `tools` (optional): A list of tools that the agent is allowed to use. This can be a comma-separated string (e.g., `tool-1, tool-2`) or a YAML array. If omitted, the agent inherits all available tools.

### System Prompt

The content of the file after the frontmatter is the system prompt for the agent. This prompt should define the agent's role, capabilities, and how it should behave.

## Using a Custom Agent

You can mention the custom agent's name in your prompt, and Pochi may decide to use it based on the context.

## Managing Custom Agents

You can manage your custom agents through the Pochi interface or by directly manipulating the agent definition files. The common operations include:

* **List**: View all available agents in the `.pochi/agents/` directory or in Pochi settings.
* **Create**: Create a new `.md` file in the `.pochi/agents/` directory.
* **Delete**: Remove the corresponding agent file.
* **Edit**: Modify the agent's definition file.


# Developer Updates
URL: /developer-updates
Weekly update notes from Pochi developers
***

title: "Developer Updates"
icon: "Newspaper"
description: "Weekly update notes from Pochi developers"
--------------------------------------------------------

# Developer Updates

Welcome to the Pochi Developer Updates ‚Äî a **weekly digest** of what's new in the codebase.

Here you will find highlights on features, enhancements, and bug fixes, plus insights into how we're improving the developer experience. Come back often! üëã

***

### Sep 19, 2025

#### TL;DR

We are excited to introduce **Queued Messages** ‚Äî type prompts in advance and stop waiting for Pochi to finish a task! We also launched a new [**Tutorials section**](https://docs.getpochi.com/tutorials/) with guides on **voice-driven development** and **Mermaid graphs**. Have tips or insights? Contribute your own via PRs! Plus, Pochi now supports more file types, and the CLI is friendlier and more interactive. ‚ú®

#### Features üöÄ

* **[Queued Messages](https://docs.getpochi.com/queued-messages/):** Don't wait around ‚Äî `‚åò/Ctrl + ‚Üµ` to line up your next prompt when Pochi is busy. [#286](https://github.com/TabbyML/pochi/pull/286)
  <div className="w-4/7 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Queued messages in prompt editor](../assets/images/queued-messages-1.png)</div>

* **[Tutorials](https://docs.getpochi.com/tutorials/):** A new documentation hub to help you get more out of Pochi. This week: [voice-driven dev with Hex](https://docs.getpochi.com/tutorials/hex/), and [Mermaid graph communication](https://docs.getpochi.com/tutorials/mermaid-graph/).

#### Enhancements ‚ú®

* **Multimedia file support:** Share not just images, but also PDFs and videos with Pochi. [#271](https://github.com/TabbyML/pochi/pull/271)

* **Claude Code login:** The CLI now supports authentication with Claude Code. [#282](https://github.com/TabbyML/pochi/pull/282)

* **Friendlier CLI experience:** Interactively pick auth vendors and navigate through tasks, get clearer help/error messages, and see upgrade notices on startup. [#287](https://github.com/TabbyML/pochi/pull/287), [#294](https://github.com/TabbyML/pochi/pull/294), [#308](https://github.com/TabbyML/pochi/pull/308), [#329](https://github.com/TabbyML/pochi/pull/329), [#357](https://github.com/TabbyML/pochi/pull/357)
  <div className="w-4/7 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Interactive task list in terminal](../assets/images/interactive-task-list.png)</div>

* **Docs updates**: Added documentation for [queued messages](https://docs.getpochi.com/queued-messages/) and [tab completion model settings](https://docs.getpochi.com/tab-completion/#tab-completion-model-settings) and improved VS Code docs. [#317](https://github.com/TabbyML/pochi/pull/317), [#321](https://github.com/TabbyML/pochi/pull/321), [#365](https://github.com/TabbyML/pochi/pull/365)

#### Bug fixes üêõ

* **VS Code UX tweaks:** Unified drag-and-drop overlays with the prompt editor, fixed tooltip arrows, and ensured model selections are preserved with clear alerts when a model is unavailable. [#350](https://github.com/TabbyML/pochi/pull/350), [#316](https://github.com/TabbyML/pochi/pull/316), [#373](https://github.com/TabbyML/pochi/pull/373)

#### New Contributors üêæ

A belated shout-out to [@DESU-CLUB](https://github.com/DESU-CLUB) for their first contribution last week ‚Äî and another one this week! ü•≥

***

### Sep 12, 2025

#### TL;DR

This week we brought **custom agents** to life!üê£ Pochi **CLI is on npm**, `newTask` makes it simple to create and manage tasks right from the terminal, and Mermaid diagrams render beautifully inside the app. MCP interactions are smarter too, and the docs and UI keep getting smoother with every update. ‚ú®

#### Features üöÄ

* **Custom Agents:** Define your own assistants in `.pochi/agents` using markdown. [#176](https://github.com/TabbyML/pochi/pull/176), [#181](https://github.com/TabbyML/pochi/pull/181)
* **`newTask` in CLI:** Spin up tasks directly from the terminal, each with its dedicated agent. [#232](https://github.com/TabbyML/pochi/pull/232)
* **Mermaid diagrams:** Drop Mermaid code blocks into Pochi and see them rendered as nice diagrams. [#255](https://github.com/TabbyML/pochi/pull/255)

<div className="w-4/7 md:ml-8 *:shadow-xl/30 *:rounded-lg">![Mermaid.js rendered diagram](../assets/images/mermaid-js-diagram.png)</div>

#### Enhancements ‚ú®

* **Pochi CLI on npm üì¶:** `npm install -g pochi` and get it running! [#238](https://github.com/TabbyML/pochi/pull/238)
* **Custom models for completion:** Use your own models for code completion in VS Code. [#251](https://github.com/TabbyML/pochi/pull/251)
* **MCP instructions:** MCP servers can now guide models on tool usage, enabling more complex interactions. [#254](https://github.com/TabbyML/pochi/pull/254)
* **Token auth:** Log in with a token when browser auth doesn't work. [#235](https://github.com/TabbyML/pochi/pull/235), [#236](https://github.com/TabbyML/pochi/pull/236)
* **Diff view focus mode:** Pochi automatically closes a file's regular editor tab when opening its diff view. [#197](https://github.com/TabbyML/pochi/pull/197)
* **More CLI commands:** `pochi mcp list` to inspect configured MCP servers, and `pochi task list` to check task lists. [#231](https://github.com/TabbyML/pochi/pull/231), [#266](https://github.com/TabbyML/pochi/pull/266)
  <div className="w-2/3">![Pochi CLI Task List](../assets/images/cli-task-list.png)</div>
* **VS Code UI polish**: Autocomplete mention list is responsive and tabbable, workflow list is collapsible and better spaced. [#215](https://github.com/TabbyML/pochi/pull/215), [#204](https://github.com/TabbyML/pochi/pull/204), [#230](https://github.com/TabbyML/pochi/pull/230), [#228](https://github.com/TabbyML/pochi/pull/228), [#242](https://github.com/TabbyML/pochi/pull/242)
* **Docs updates:** Added checkpoint feature and updated GitHub integration docs with API key setup. [#203](https://github.com/TabbyML/pochi/pull/203), [#262](https://github.com/TabbyML/pochi/pull/262)

#### Bug fixes üêõ

* **Scoped replies:** Pochi only responds when you start a comment with `/pochi`. [#202](https://github.com/TabbyML/pochi/pull/202)

***

### Sep 5, 2025

#### TL;DR

We had a massive week ‚Äî **62 PRs shipped** üéâ!

Pochi can now reply to you right in **GitHub comments & issues**, the interface speaks more languages with new **i18n support**, and we rolled out a sleeker, more powerful **background job system**. On top of that, the **CLI** got smarter, **autocomplete** got friendlier, and the **docs** got a glow-up!

#### Features üöÄ

* **GitHub Action integration:** Pochi now lives in your PR comments / issues! Ask for help in a PR with `/pochi`. [#76](https://github.com/TabbyML/pochi/pull/76)
* **Internationalization (i18n):** The VS Code extension now supports üá∫üá∏ üá®üá≥ üáØüáµ üá∞üá∑. Want your language included? Open a PR! [#90](https://github.com/TabbyML/pochi/pull/90)

#### Enhancements ‚ú®

* **CLI upgrades:** The Pochi CLI got a big boost this week!
  * Install via Homebrew üç∫ [#125](https://github.com/TabbyML/pochi/issues/125)
  * Authenticate with `pochi auth`, including support for Gemini login [#167](https://github.com/TabbyML/pochi/pull/167)
  * Trigger workflows directly with `pochi -p "/create-pr"` [#110](https://github.com/TabbyML/pochi/pull/110)
* **Enhanced Background jobs:** Added terminal integration and lifecycle controls. Enhanced the job UI with collapsible detail logs and readable IDs for a clearer experience. [#81](https://github.com/TabbyML/pochi/pull/81), [#97](https://github.com/TabbyML/pochi/pull/97)
* **Autocomplete:** Pochi suggests relevant tools, functions, and variables to help you type prompts faster. [#89](https://github.com/TabbyML/pochi/pull/89)
* **Documentation updates:** Refreshed CLI usage docs, expanded model provider configuration examples, and added Slack integration documentation. [#133](https://github.com/TabbyML/pochi/pull/133), [#141](https://github.com/TabbyML/pochi/pull/141), [#82](https://github.com/TabbyML/pochi/pull/82)

#### Bug Fixes üêõ

* **File writing reliability:** The CLI ensures directories exist before writing, so `writeToFile` tool won't fail. [#118](https://github.com/TabbyML/pochi/pull/118)
* **Code completion fix:** Corrected how VS Code calculates the replacement range for suggestions, so completions insert correctly. [#131](https://github.com/TabbyML/pochi/pull/131)

#### New Contributors üêæ

[@karim-coder](https://github.com/karim-coder) made their first contribution this week! Welcome aboard! üéâ

***

### Aug 29, 2025

#### TL;DR

This week we polished the VS Code extension with some **UX upgrades**, open-sourced the **Pochi CLI**, and did a few rounds of **codebase cleanup** to make contributing easier and friendlier for newcomers. We look forward to your first visit to the repo!

#### Enhancements ‚ú®

* **Drag & drop images:** Share visuals with Pochi in the VS Code chat just by dragging them in. [#64](https://github.com/TabbyML/pochi/pull/64)
* **Improved docs:** Updated structure and added guidance on model settings for easier use. [#60](https://github.com/TabbyML/pochi/pull/60), [#63](https://github.com/TabbyML/pochi/pull/63) , [900d162](https://github.com/TabbyML/pochi/commit/900d1629c4e97833e24a4450c438a585dca583d4)
* **Model pricing at your fingertips:** Check model costs directly in settings before choosing one. [#74](https://github.com/TabbyML/pochi/pull/74)

#### Bug Fixes üêõ

* **File search now correctly surfaces matching files:** Queries that used to return empty results will now behave as expected. [#79](https://github.com/TabbyML/pochi/pull/79)


# GitHub
URL: /github

***

title: GitHub
icon: "Github"
--------------

# GitHub

Use Pochi's AI assistant directly in your GitHub repository by commenting on pull requests to perform code reviews, explain changes, and suggest improvements.

<Callout type="info" title="How it works">
  This integration runs inside a GitHub Actions runner. It temporarily installs
  the pochi CLI and executes tasks in the context of your repository. Progress
  is continuously updated under the triggering comment, and a final result
  (‚úÖ/‚ùå) is posted when finished.
</Callout>

## Getting Your API Keys

1. Log in to your Pochi account and go to **API Keys** from your user menu

![User button overview](../assets/images/api-overview.png)

2. Create a new API key with a descriptive name
3. Copy the generated key (it's only shown once)

![API page interface](../assets/images/api-page-interface.png)

4. Add it to your GitHub repository as a secret named `POCHI_API_KEY`. See [GitHub's official guide](https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets) for detailed steps:
   * Go to **Settings** ‚Üí **Secrets and variables** ‚Üí **Actions**
   * Click **"New repository secret"**
   * Name: `POCHI_API_KEY`, Value: your API key

## Setup

Create a workflow file `.github/workflows/pochi.yml` in your repository:

```yaml
name: pochi

on:
  issue_comment:
    types: [created]

jobs:
  pochi:
    if: startsWith(github.event.comment.body, '/pochi')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run pochi
        uses: tabbyml/pochi/packages/github-action@main
        env:
          # Required: Pochi session token (get it from app.getpochi.com and add as a repository secret)
          POCHI_API_KEY: ${{ secrets.POCHI_API_KEY }}
          # Optional: custom model (defaults to CLI's default model if not set)
          # See the Models page for model options and configuration
          # POCHI_MODEL: google/gemini-2.5-pro
```

Notes:

* Triggered by `issue_comment` (created) and runs only if the comment body starts with `/pochi`
* Requires write permissions to read changes, post comments, and add reactions to PRs
* Provide `POCHI_API_KEY` via env; optionally set `POCHI_MODEL` to customize the model
* By default, the action uses GitHub's built-in `GITHUB_TOKEN` (github-actions bot). You can customize this by setting a custom `GITHUB_TOKEN` environment variable with your own Personal Access Token (PAT)

## Usage

Comment on a PR with `/pochi` followed by your request, e.g. `/pochi review this code`, `/pochi explain the changes in this PR`, `/pochi suggest improvements`.

![Comment example](../assets/images/github-comment.png)

Once triggered:

* Pochi reacts to your comment with üëÄ to indicate it's running
* A progress comment is updated every 15 seconds
* When finished, it posts the final result and reacts with üöÄ (success) or ‚àí1 (failure)

![Progress example](../assets/images/github-progress.png)

![Actions run example](../assets/images/github-action-run.png)

Permission requirement: Only users with write/admin permission can trigger execution. Otherwise, an error will be posted as a comment.

## Advanced configuration

### Use a custom GitHub token (optional)

By default, the action uses the GitHub-provided `GITHUB_TOKEN`. For cross-repo or higher-privileged operations, you can override it with a PAT:

```yaml
- name: Run pochi
  uses: tabbyml/pochi/packages/github-action@main
  env:
    GITHUB_TOKEN: ${{ secrets.CUSTOM_GITHUB_TOKEN }} # Your PAT
    POCHI_API_KEY: ${{ secrets.POCHI_API_KEY }}
```

### Permissions

Ensure the workflow includes these permissions:

```yaml
permissions:
  contents: write # Read repo contents and commit changes if needed
  issues: write # Comment on issues/PRs
  pull-requests: write # Access PR information and status
```


# Getting Started
URL: /
Welcome to Pochi - Full-Stack AI Teammate Guide
***

title: "Getting Started"
description: "Welcome to Pochi - Full-Stack AI Teammate Guide"
icon: "Album"
-------------

# Getting Started

[Pochi](https://getpochi.com) is an open-source AI coding agent built as a VS Code extension, checkout the video below to see it in action.

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  marginBottom: 20,
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1CDxAcO9WGFFC45x5a5HDFdT4u6rtdJrB/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Pochi Demo - End-to-End Experience"
  />
</div>

## Installation

Install the Pochi extension from the [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=TabbyML.pochi) or [OpenVSX](https://open-vsx.org/extension/TabbyML/pochi).

We recommend dragging Pochi to the right side of your VSCode window to get the best experience.

![Drag to right sidebar](../assets/images/vscode-right-sidebar.png)

With Pochi, you can use any LLM provider by configuring their API keys. Use the VS Code command `Pochi: Open Custom Model Settings` to open the settings file and [configure it](./models). Alternatively, Pochi offers cloud-based services. Creating a Pochi account gives you access to:

* Pochi's managed LLM models
* Shared task histories and team management
* Integrations with GitHub and Slack for a collaborative workflow

To use these features, sign up at [app.getpochi.com](http://app.getpochi.com) and log in to your VS Code extension.

## Customize

You can tailor Pochi to your needs by editing its configuration file, located at `~/.pochi/config.jsonc`. The file uses the JSONC (JSON with Comments) format, so you can add notes to explain your settings.

```jsonc
{
  // The schema enables autocompletion and validation in your code editor.
  "$schema": "https://getpochi.com/config.schema.json",

  // For details on available options, see the "Models," "Rules," pages in the sidebar
  // ...
}
```


# MCP
URL: /mcp
Model Context Protocol integration and configuration
***

title: MCP
description: Model Context Protocol integration and configuration
icon: "Spline"
--------------

# MCP (Model Context Protocol)

The **Model Context Protocol (MCP)** revolutionizes how Pochi interacts with external services, databases, and APIs. Think of MCP as a universal adapter that connects Pochi to virtually any data source or tool, dramatically expanding what your AI assistant can accomplish.

## Configure

Use the VSCode command `Pochi: Open MCP Server Settings` to open the settings.

```json
{
  "mcp": {
    "context7": {
      "command": "npx",
      "args": ["@upstash/context7-mcp"]
    }
  }
}
```

After saving the configuration, you will see the MCP server appear in the **Tools** section of Pochi's settings page.

![MCP Server Context7](../assets/images/mcp-context7.png)

You can use the toggle switch to enable or disable the MCP server entirely. You can also click on the tool badge to toggle individual tools within the MCP server.

## Examples

### Local MCP Servers (Stdio Transport)

```json
{
  "filesystem": {
    "command": "npx",
    "args": [
      "-y",
      "@modelcontextprotocol/server-filesystem",
      "/path/to/allowed/files"
    ],
    "env": {
      "HOME": "/Users/yourname"
    }
  }
}
```

### Remote MCP Servers (HTTP Transport)

#### Custom API Server

```json
{
  "my-api": {
    "url": "https://api.mycompany.com/mcp",
    "headers": {
      "Authorization": "Bearer your-api-token",
      "X-API-Version": "v1"
    }
  }
}
```

#### SSE (Server-Sent Events) Server

```json
{
  "realtime-data": {
    "url": "https://data.example.com/mcp/sse",
    "headers": {
      "Authorization": "Bearer your-token"
    }
  }
}
```


# Models
URL: /models
Manage Pochi's model settings
***

title: Models
description: Manage Pochi's model settings
icon: "Zap"
-----------

# Models

Pochi leverages the AI SDK to support various LLM providers and can run local models.

## Pochi

After signing in, you gain access to the Pochi models shown below. Pochi uses a usage-based pricing strategy with no additional charges. For detailed pricing information, visit [https://app.getpochi.com/pricing](https://app.getpochi.com/pricing).

![Pochi Models](../assets/images/pochi-models.png)

## GitHub Copilot

For Microsoft VS Code distributions, you can utilize your enabled Copilot models within Pochi.

![Copilot Models](../assets/images/copilot-models.png)

## OpenAI Compatible

Pochi allows you to configure any LLM provider that offers an OpenAI-compatible API by setting up the appropriate API keys. To configure custom models, use the VS Code command `Pochi: Open Custom Model Settings` to open the settings configuration file.

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "provider-id": {
      "apiKey": "your_api_key",
      "baseURL": "https://api.provider.com/v1",
      "models": {
        "model-id": {
          // The contextWindow and maxTokens are optional right now, it's default set to 10k and 4096
          // "contextWindow": 131072,
          // "maxTokens": 8000
        }
      }
    }
  }
}
```

### Chutes

Chutes provides access to various AI models through their API. To use Chutes, you'll need to obtain an API token from [Chutes Platform](https://chutes.ai/).

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "chutes": {
      "apiKey": "your_api_token",
      "baseURL": "https://llm.chutes.ai/v1",
      "models": {
        "zai-org/GLM-4.5-FP8": {
          "name": "glm-4.5"
        }
      }
    }
  }
}
```

### Cerebras

Cerebras provides AI models through their OpenAI-compatible API. To use Cerebras, you'll need to obtain an API key from [Cerebras Platform](https://inference.cerebras.ai/).

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "cerebras": {
      "apiKey": "your_api_key",
      "baseURL": "https://api.cerebras.ai/v1",
      "models": {
        "llama3.1-8b": {
          "name": "llama-3.1-8b"
        }
      }
    }
  }
}
```

### DeepInfra

DeepInfra provides access to a wide range of AI models through their OpenAI-compatible API. To use DeepInfra, you'll need to obtain an API token from [DeepInfra Platform](https://deepinfra.com/).

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "deepinfra": {
      "apiKey": "your_api_token",
      "baseURL": "https://api.deepinfra.com/v1/openai",
      "models": {
        "meta-llama/Llama-3.3-70B-Instruct": {
          "name": "llama-3.3-70b"
        }
      }
    }
  }
}
```

### Groq

Groq is a cloud-based AI platform that provides fast inference for large language models.

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "groq": {
      "apiKey": "your_api_key",
      "baseURL": "https://api.groq.com/openai/v1",
      "models": {
        "llama3-8b-8192": {
          "name": "llama-3-8b"
        }
      }
    }
  }
}
```

### LM Studio

LM Studio is a local IDE application that allows you to run and experiment with language models on your own machine.

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "lmstudio": {
      "baseURL": "http://127.0.0.1:1234/v1",
      "models": {
        "gemma-2b-it-q4f32_1": {
          "name": "gemma-2b"
        }
      }
    }
  }
}
```

### Mistral

Mistral AI provides a range of powerful language models available through their API. To use Mistral models, you'll need to obtain an API key from [Mistral AI Platform](https://console.mistral.ai/).

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "mistral": {
      "apiKey": "your_api_key",
      "baseURL": "https://api.mistral.ai/v1",
      "models": {
        "mistral-small-latest": {
          "name": "mistral-small"
        }
      }
    }
  }
}
```

### Ollama

Ollama is a tool that allows you to run large language models locally on your machine with a simple API.

```json
{
  "$schema": "https://getpochi.com/config.schema.json",
  "providers": {
    "ollama": {
      "baseURL": "http://localhost:11434/v1",
      "models": {
        "llama3:8b": {
          "name": "llama-3-8b"
        }
      }
    }
  }
}
```


# Permissions
URL: /permissions
Manage Pochi's auto-approval settings
***

title: Permissions
description: Manage Pochi's auto-approval settings
icon: "Shield"
--------------

# Permissions

By default, all permissions in Pochi are enabled. You can customize these permissions at any time using the Auto-Approve settings.

<div align="center">
  ![Auto Approve](../assets/images/auto-approve.png)
</div>

* **Read**: Read the file content Pochi decides to look up for analyzing or completing tasks.
* **Write**: Creates new files, edits existing code, generates boilerplate, and writes documentation.
* **Execute**: Manages dependencies, runs builds, tests, and perform system operations.
* **Use MCP**: Interacts with databases, APIs, and other external services to expand its capabilities with MCP server.
* **Retry**: Automatically retries failed commands, code changes, and installations.


# Queued Messages
URL: /queued-messages
Add tasks to a queue while Pochi is busy, ensuring a non-blocking experience.
***

title: Queued Messages
description: Add tasks to a queue while Pochi is busy, ensuring a non-blocking experience.
icon: "Layers"
--------------

# Queued Messages

The Queued Messages feature allows you to add multiple messages to a queue, which are then combined into a single prompt for execution. This lets you build up a complex request in pieces, which is especially useful while Pochi is busy.

<div align="center">
  ![Queued Messages UI](../assets/images/queued-messages.png)
</div>

When Pochi is busy, you don't have to wait to give it your next instruction. Here‚Äôs what happens:

1. **Queue with a Shortcut**: Type your prompt and press `Cmd+Enter` (`Ctrl+Enter` on Windows/Linux). Your message will be added directly to the queue.
2. **See What's in Line**: The "Queued Messages" panel appears, showing you a list of all the tasks waiting to be executed.
3. **Combined for Execution**: Once Pochi is ready, it will take all the messages from the queue, merge them into a single prompt, and then execute it.
4. **Remove with a Click**: If you decide you don't need a task done anymore, just click the `X` next to it to remove it from the queue.


# Rules
URL: /rules
Define coding standards and development guidelines
***

title: Rules
description: Define coding standards and development guidelines
icon: "Ruler"
-------------

# Rules

You can provide custom instructions to Pochi by creating an `README.pochi.md` file. This is similar to CLAUDE.md or Cursor‚Äôs rules.

<Callout title="AGENTS.md support">
  Pochi also supports [AGENTS.md](https://agents.md) as an alternative to `README.pochi.md`. Both files serve the same purpose and are treated identically by Pochi.
</Callout>

### Example

Below example is the `README.pochi.md` file for Pochi itself.

```markdown
Pochi is an project developed using following technologies:
1. always use kebab-case for filenames.
2. always use camelCase for variables, functions.
3. use PascalCase for classes, interfaces, types.

# Testing for non packages/vscode
We use vitest framework.
our test use vitest framework.
test command: `bun run test`
coverage test command: `bun run test -- --coverage`

## Testing for packages/vscode
We use mocha framework, when creating test, do not use mocks for filesystem, just use vscode.workspace.fs to create files and folders, and only use mocha primitives for testing. use sinon for mocks.

(assuming cwd is packages/vscode)
test command: `bun run test`
coverage test command: `bun run test:coverage`

When encountering issues like `TypeError: Descriptor for property readFile is non-configurable and non-writable`, please use `proxyquire` to mock the module.

# Misc
1. use `bun check` to format / linting the code, use `bun fix` to automatically apply the fix.
2. use `bun tsc` to check the types.
3. For packages/code it uses `ink` for react terminal ui.
4. Prefer `@/lib` over `../lib` for imports.
5. For global variable in typescript, prefer using PascalCase, e.g `GlobalVariableName`, instead of `GLOBAL_VARIABLE_NAME`.
6. For biome related warning / errors, prefer using `bun fix` in the root directory to fix the issues.
```

## Locations

Pochi looks for rules in two locations:

### Workspace

Pochi first checks for a `README.pochi.md` (or `AGENTS.md`) file in your current workspace root directory. This is where you define project-specific rules that apply only to your current project.

### Global

Pochi also reads global rules defined in `~/.pochi/README.pochi.md`. These rules apply to all projects and are suitable for any personal rules that Pochi should follow.

You can view current active rules in toolbar's token usage popover

<div align="center">
  ![Token Usage](../assets/images/usage-token-popover.png)
</div>


# Share
URL: /share
Share your development context with team members
***

title: Share
description: Share your development context with team members
icon: "Share2"
--------------

# Share

The **Share** feature in Pochi's toolbar allows you to share your current development context with others.

<Callout type="info" title="Public Access">
  Shared conversations are publicly accessible to anyone with the link. Do not share sensitive information or private code.
</Callout>

<div align="center">
  ![Task Sharing](../assets/images/task-sharing.png)
</div>

### How it works

When you share a conversation, Pochi:

1. Persist your task to our servers, and create a unique public URL for the task..
2. Makes task accessible via a link - `app.getpochi.com/share/<shareId>`


# Slack
URL: /slack
Pochi's integration with Slack
***

title: Slack
description: Pochi's integration with Slack
icon: "Slack"
-------------

# Slack

Pochi's Slack integration allows you to use Pochi directly within your Slack workspace, bringing AI-powered development assistance to your team conversations.
Start tasks in Slack and seamlessly switch to the Cloud IDE when you need the full development experience.

<Callout type="info" title="Cloud IDE">
  When you send messages to Pochi in Slack, tasks are executed in remote environment running in the cloud. You can switch to the Cloud IDE to continue working on the task.
</Callout>

## Getting Started

### Adding Pochi to Your Workspace

1. **Install the Integration**: Add Pochi to your Slack workspace through the `Add to Slack` button on the [homepage](https://app.getpochi.com/home)
   ![Slack Installation](../assets/images/slack-install-home.png)
2. **Authorize Access**: Grant the necessary permissions for Pochi to interact with your Slack channels
   ![Slack Authorization](../assets/images/slack-authorize.png)
3. **Start Collaborating**: Begin using Pochi in any channel or direct message where it's been added. If using channels, please make sure to invite Pochi to the channel before creating a task.

### Basic Usage

Once Pochi is added to your workspace:

1. \[Optional] **Invite Pochi to Channels**: If you want to interact with Pochi in channels, simply send `@Pochi` in the channel, and you will be prompted to invite Pochi to the channel.
2. \[Optional] **Default Github Repository**: Set the repository in the Channel Topic, so Pochi knows which repository to work on by default.
   * Format: `[repo:OWNER/REPO]`, for example, `[repo:TabbyML/pochi]`
3. **Start Task**: Send a task prompt to Pochi in Direct Messages or channels using the following format:
   * If a default repository is set: `/newtask PROMPT`, for example, `/newtask What are recent commits`
   * If no default repository is set or you want to run Pochi with another repository : `/newtask [OWNER/REPO] PROMPT`, for example, `/newtask [TabbyML/tabby] What are recent commits`
4. **Real-time Updates**: Watch as Pochi executes tasks and provides updates directly in Slack.
5. **Follow-up**: After the task is completed, Pochi might ask some follow-up questions, or you can provide responses clicking the option buttons or the Reply button.

![Slack Task](../assets/images/slack-task.png)

### Continue in Cloud IDE

When you need the full IDE experience:

1. **Access Task Page**: Click on the `See Details` button to navigate to the task in Pochi's web interface.
2. **Click Remote Icon**: Look for the remote/external link icon in the task interface.
   ![Slack Remote Button](../assets/images/slack-remote-button.png)
3. **Continue Development**: Pick up exactly where you left off.
   ![Slack VSCode Web](../assets/images/slack-vscode-web.png)

## Frequently Asked Questions

### Why do I get a `not_in_channel` error when creating a task in a channel?

Verify that Pochi has been properly added to the channel. If Pochi is not invited to the channel, mention @Pochi in the channel to invite it.

### Why can't I access the Cloud IDE?

Only the Task Owner has permission to access the Cloud IDE. Make sure you are the Task Owner and logged in to Pochi with the same account in your browser.


# Tab Completion
URL: /tab-completion
Inline code completion
***

title: Tab Completion
description: Inline code completion
icon: "Code"
------------

# Tab Completion

**Tab Completion** is Pochi's in-editor inline code completion feature that provides AI-powered suggestions as you type, helping you write code faster and more efficiently.

Pochi uses a state-of-the-art model that adapts to your coding patterns in real time,
drawing on recent edits, diagnostics, and surrounding context to generate helpful,
relevant completions right in your editor.

<div align="center">
  ![Tab completion showing inline suggestions](../assets/images/completion.png)
</div>

### Multi-Language Support

Works across popular programming languages including:

* JavaScript/TypeScript
* Python
* Java
* C/C++
* Go
* Rust
* And many more

## Using Tab Completion

### Basic Usage

1. Start typing your code
2. Pochi will show inline suggestions in gray text
3. Press `Tab` to accept the suggestion
4. Press `Escape` to dismiss the suggestion

### Keyboard Shortcuts

| Key            | Action                                      |
| -------------- | ------------------------------------------- |
| `Tab`          | Accept the current suggestion               |
| `Escape`       | Dismiss the suggestion                      |
| `Ctrl/Cmd + ‚Üí` | Accept word by word                         |
| `Alt + ]`      | Next suggestion (if multiple available)     |
| `Alt + [`      | Previous suggestion (if multiple available) |

## Tab Completion Model Settings

You can customize the code completion provider in your VS Code settings, allowing you to switch between different models, including those running on your local machine.

By default, Pochi uses its own hosted code completion model. Alternatively, you can configure Pochi to use any OpenAI-compatible server that provides a Fill-in-the-Middle (FIM) completion model.

Here is an example configuration for a local OpenAI-compatible server running `qwen3-coder-30b-a3b` on port 8000:

```json
  "pochi.advanced": {
    "inlineCompletion": {
      "provider": {
        "type": "openai",
        "baseURL": "http://127.0.0.1:8000/v1",
        "apiKey": "",
        "model": "qwen3-coder-30b-a3b",
        "promptTemplate": "<|fim_prefix|>{{prefix}}<|fim_suffix|>{{suffix}}<|fim_middle|>"
      }
    }
  },
```

* **baseURL**: The base URL of the OpenAI-compatible server.
* **apiKey**: The API key for the server. If not set, Pochi will use the `POCHI_CODE_COMPLETION_OPENAI_API_KEY` environment variable. This can be left empty if the server does not require an API key.
* **model**: The name of the FIM completion model to use.
* **promptTemplate**: The prompt template for FIM completion. It must include `{{prefix}}` and `{{suffix}}` placeholders.

***

**Need help?** Join our [Discord](http://getpochi.com/discord) for assistance with Tab Completion features.


# Troubleshooting
URL: /troubleshooting
Common issues and how to resolve them
***

title: "Troubleshooting"
icon: "CircleQuestionMark"
description: "Common issues and how to resolve them"
----------------------------------------------------

# Troubleshooting

To debug any issues with Pochi, you can check the logs from webview console or vscode output console.

### Webview Console

1. Open `Developer: Use Webview Developer Tools` command in VSCode
2. Go to the Console tab
3. Look for error messages related to Pochi

You can configure the log level in VSCode Settings with following snippet

```json
{
  "pochi.advanced": {
      "webviewLogLevel": "DEBUG" // Set to "DEBUG" to see more detailed logs
  },
}
```

### VSCode Output Console

1. Use `Output: Show Output Channels` command in VSCode
2. Select "Pochi" from the dropdown
3. Look for error messages or warnings

# Getting help

If you‚Äôre experiencing issues with Pochi:

1. Report issues on Github

   The best way to report bugs or request features is through our GitHub repository: [https://github.com/TabbyML/pochi/issues](https://github.com/TabbyML/pochi/issues)

2. Join our Discord

   For real-time help and community discussion, join our Discord server: [https://getpochi.com/discord](https://getpochi.com/discord)


# VS Code
URL: /vscode

***

title: VS Code
icon: "LayoutPanelLeft"
-----------------------

# VS Code

This page covers the core Pochi experience in VS Code, from installation and setup to the main chat and task management features.

## Installation

Install the Pochi extension from the [VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=TabbyML.pochi) or [OpenVSX](https://open-vsx.org/extension/TabbyML/pochi).

For the best experience, we recommend dragging the Pochi view to the right sidebar to use it side-by-side with your editor.

![Drag the Pochi view to the right sidebar for a side-by-side experience.](../assets/images/vscode-right-sidebar.png)

## Welcome

Upon first launch, Pochi's Welcome page offers two ways to get started:

* **Sign in to Pochi:** Click "Sign In" and authorize in your browser to use Pochi subscriptions, models, and cloud features.
* **Bring Your Own Key (BYOK):** Use your own models by running `Pochi: Open Custom Model Settings` from the Command Palette. This opens `~/.pochi/config.jsonc` for you to add API keys. See [Models](/models) for details.

<div align="center">![The Welcome page provides options to sign in or configure your own models.](../assets/images/welcome-page.png)</div>

## Chat

Access the Pochi chat panel via the Activity Bar icon or shortcut (macOS: `Cmd+L`, Win/Linux: `Ctrl+L`). This is your main interface for interacting with Pochi. **Note:** An active workspace (i.e., an open folder) is required to use the chat.

The panel's title bar includes actions for starting a new task and viewing all tasks.

<div align="center">![The main Chat panel is where you interact with Pochi.](../assets/images/chat-page.png)</div>

## Prompting

The input box, located below the chat history, is where you'll compose your messages and control the chat.

* **Auto-Approve Menu:** This menu at the top of the zone allows you to grant Pochi permission to use tools autonomously, streamlining the workflow.
* **Todo List:** When Pochi creates a to-do list for a task, it will appear here, allowing you to track progress.
* **Chat Input:** The main text area supports both text and image uploads. You can attach files by clicking the **paperclip icon** or by dragging and dropping them into the input area.
* **Bottom Toolbar:** The toolbar at the very bottom provides several key functions:
  * **Model Selector:** Choose which language model you want to interact with.
  * **Token Usage & Compact Task:** Monitor the token count of your conversation. If the conversation becomes long, a **Compact Task** button will appear, allowing you to condense the history and save tokens.
  * **Sharing:** Share your chat session with others (requires a Pochi account).
  * **Submit/Stop Button:** The send button dynamically transforms into a stop button during message generation, allowing you to interrupt the AI at any time.

<div align="center">
  ![The Prompt Zone provides access to key features like model selection and auto-approval.](../assets/images/home-page-toolbox.png)
</div>

## Tasks

A chat session in Pochi is saved as a **Task**. You can view your entire task history from the task list page.

Some AI-powered actions might generate a **Sub-task**, which is a new, focused chat session dedicated to a specific part of the original task.
When you're in a sub-task, you'll see a "Back" button to navigate to the parent task, allowing you to maintain context while breaking down complex problems.
By default sub-tasks are hidden in the task list.

By default, task history is stored locally. Signing in to a Pochi account enables cloud storage for your tasks, along with sharing and team collaboration features.
Be aware that clearing VS Code's extension data may erase your local task history.

<div align="center">![The Task List page shows your historical task sessions.](../assets/images/task-page.png)</div>

## Troubleshooting

Having issues? Here are a few things to check:

* **No Active Workspace:** Pochi requires an open folder to function correctly. Make sure you have a workspace open.
* **Sign-in/Model Configuration:** Verify that you are either signed in to your Pochi account or have a valid API key configured in your `~/.pochi/config.jsonc`.

For more help, check the full [Troubleshooting](/troubleshooting) page or join our community on [Discord](https://getpochi.com/discord).


# Workflows
URL: /workflows
Automate common development sequences
***

title: Workflows
description: Automate common development sequences
icon: "Workflow"
----------------

# Workflows

Workflows are step-by-step automation templates that guide Pochi through complex, multi-step processes. Think of them as detailed recipes that Pochi can follow to complete common development tasks consistently and efficiently.

### Configure

Workflows shall be put inside `.pochi/workflows/` directory in your workspace root. Each workflow is a markdown file with a specific name.

`.pochi/workflows/create-pr.md` is an example we used in Pochi's own development.

```markdown
Please help create a PR for the current staging changes, following these guidelines:
- If there are no staging changes but there are uncommitted changes, please stage them first.
- Create a branch name based on the current git diff status.
- Write a meaningful commit message/PR title.
- Use the gh CLI to create a PR.
- When running the push operation, it might be aborted due to a husky pre-push hook. For formatting issues, amend the files and try again. For other issues, try to resolve them as much as possible.
- The base branch for the PR should always be `main`.
- Always push the branch to the remote repository before creating the PR.

When creating PR with markdown description, pay attention to escape backticks, otherwise it will be executed as command substitution in the shell.
```

### Usage

Once your workflows are set up, using them is straightforward:

1. **Type `/` in VS Code** to trigger the Pochi workflow selector
2. **Select a workflow** from the dropdown menu and press `Enter`.
3. You can attached additional context when running the workflow, e.g `/create-pr assign Meng for review after creation`.

<div
  style={{
  position: "relative",
  paddingBottom: "53.7%",
  height: 0,
  overflow: "hidden",
  maxWidth: "100%",
}}
>
  <iframe
    src="https://drive.google.com/file/d/1p9UeAfkLEOlXBABF4CGub_aqAlAnmbVe/preview"
    style={{
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px",
  }}
    allowFullScreen
    title="Pochi Demo - Workflows"
  />
</div>

*This video demonstrates how to use workflows in VS Code*


# Connect to Tabby Server for Enhanced Enterprise Experience
URL: /tutorials/connect-to-tabby-server

***

## title: Connect to Tabby Server for Enhanced Enterprise Experience

# Connect to Tabby Server for Enhanced Enterprise Experience

This tutorial will guide you through the process of connecting Pochi to your self-hosted Tabby server. By connecting Pochi to your self-hosted Tabby server, you can take advantage of several benefits, including centralized account management, self-hosted tracking, and the ability to use your own custom models.

## Prerequisites

Before you start, make sure you have a running Tabby server instance. If you don't have one, you can follow the instructions on the [Tabby website](https://tabby.tabbyml.com/) to set one up.

## Configuration

Pochi uses a configuration file to connect to different model providers. To connect to Tabby, you'll need to add a new provider configuration to your `~/.pochi/config.json` file.

Here's a sample configuration for connecting to a Tabby server:

```jsonc
{
    "kind": "openai",
    "id": "tabby",
    "baseURL": "https://demo.tabbyml.com/v1",
    "apiKey": "YOUR_AUTH_TOKEN",
    "models": [
        {
            "id": "default",
            // This flag is important for Tabby to work properly with Pochi
            "useToolCallMiddleware": true
        }
    ]
}
```

### Parameters

You'll need to change the following parameters in the configuration:

* `baseURL`: Change this to the URL of your Tabby server instance.
* `apiKey`: Change this to your own auth token from the Tabby UI. You can find your token in the "Token" section of the Tabby admin panel, as shown in the screenshot below.

<div align="center">
  ![Tabby Auth Token](./images/tabby-auth-token.png)
</div>

## Conclusion

Once you have updated the configuration file, Pochi will be able to connect to your Tabby server and use the models you have configured.


# Voice-Driven Development with Hex and Pochi
URL: /tutorials/hex

***

## title: 'Voice-Driven Development with Hex and Pochi'

# Voice-Driven Development with Hex and Pochi

This tutorial guides you through setting up an efficient, voice-driven development workflow by combining two powerful tools: **[Hex](https://github.com/kitlangton/Hex)** for local voice transcription and **[Pochi](https://github.com/TabbyML/pochi)** as your AI coding assistant.

This setup allows you to speak commands, have them transcribed into text by Hex, and then have Pochi execute those commands, creating a seamless, hands-free coding experience.

### What You Will Learn

* How to install and configure Hex for voice-to-text transcription.
* How to integrate Hex with Pochi to create a voice-driven development workflow.
* Tips for optimizing your setup for accuracy and efficiency.

### Prerequisites

* **Pochi**: You should have Pochi installed and running in your editor.
* **Apple Silicon Mac**: Hex is currently available only for Macs with Apple Silicon.

### How It Works

* **Hex** listens to your voice and converts it into text using its own built-in transcription models.
* **Pochi** takes the text generated by Hex as a command and processes it using its configured AI model.

> **For a Fully Private Workflow**
> This tutorial focuses on the voice input aspect. For complete privacy and offline use, you can configure Pochi to use a local Large Language Model (LLM). See Pochi's documentation on [model configuration](../../models) for more details.

***

## Step 1: Install and Configure Hex

Hex is an open-source macOS app that records your voice via a hotkey and pastes the transcribed text into any application.

1. **Download Hex**: Get the latest version from the [official releases page](https://hex-updates.s3.us-east-1.amazonaws.com/hex-latest.dmg).

2. **Install and Grant Permissions**:
   * Open the downloaded `.dmg` file and drag Hex into your `Applications` folder.
   * On first launch, macOS will ask for **Microphone** and **Accessibility** permissions. You must grant these so Hex can record your voice and paste the text into Pochi's chat window.

3. **Configure Hex Settings**:
   Once installed, open Hex's preferences to fine-tune its behavior.

   **A. Set Your Hotkey**
   This is the key you'll press to activate Hex. Choose a key or combination that doesn't conflict with other apps. The `Ignore below` slider helps prevent accidental triggers from very short key presses.

   ![Hex Hotkey Setting](./images/hotkey-setting.png)

   Hex also supports two recording modes:

   * **Press-and-hold**: Start recording when you press the hotkey, and stop when you release it.
   * **Double-tap**: Double-tap the hotkey to lock recording, then tap it again to stop.

   **B. Select Your Transcription Model**
   Hex uses local models based on [WhisperKit](https://github.com/argmaxinc/WhisperKit) to ensure privacy and speed. You can choose a model that balances accuracy and performance for your needs.

   ![Hex Transcription Model Settings](./images/transcription-model-setting.png)

   * **Model Size**: Larger models (like `Large` at 1.5GB) offer higher accuracy but are slower and consume more resources. The `Small` model is faster but may be less accurate. A good starting point is the `Large` model if you prioritize accuracy.
   * **Output Language**: You can select the language for your transcription, which is useful if you prefer to give commands in a language other than English.

> **Note**: The first time you select a model, Hex will download and compile it. A process called `ANECompilerService` may cause high CPU usage during this one-time optimization step. This is normal.

## Step 2: The Voice Coding Workflow in Action

With Hex installed, let's try the workflow.

1. **Open Pochi**: Launch Pochi's chat interface in your code editor.

2. **Activate Hex**: Click inside Pochi's input box, then use the hotkey you configured for Hex. When Hex is actively listening, it will display a recording indicator on your screen.

   ![Hex Recording Indicator](./images/recording-indicator.png)

3. **Speak Your Command**: Clearly state the task you want Pochi to perform. For example:
   > Write a TypeScript function that takes an array of strings and returns the longest one.

4. **Transcription**: When you stop recording, Hex transcribes your speech and pastes the text into Pochi's input box.

5. **Execution**: Pochi takes this text and sends it to its configured AI model for processing. The generated code or response appears in the chat.

## Tips and Troubleshooting

* **Inaccurate Transcription?**
  In Hex settings, try selecting a larger transcription model for better accuracy.

* **Need Help with Hex?**
  For questions or feedback specifically about Hex, join their [Discord community](https://discord.gg/5UzVCqWmav).

## Conclusion

By combining Hex and Pochi, you've created a fast and efficient voice-powered programming environment. This setup gives you a modern, hands-free way to translate your ideas into code.


# Tutorials
URL: /tutorials

***

title: Tutorials
icon: BookOpenText
------------------

# Tutorials

Welcome to the Pochi tutorials section. Here you will find step-by-step guides to help you get the most out of Pochi.

* [Voice-Driven Development with Hex and Pochi](./hex)
* [Visual Communication with Mermaid Graphs](./mermaid-graph)


# Visualizing the Dialogue: How Pochi Uses Mermaid Graphs to Communicate
URL: /tutorials/mermaid-graph

***

## title: "Visualizing the Dialogue: How Pochi Uses Mermaid Graphs to Communicate"

# Visualizing the Dialogue: How Pochi Uses Mermaid Graphs to Communicate

When Pochi tackles a large-scale code change, a monologue of text and code is not an effective way to collaborate. To have a clear dialogue with you, Pochi translates its plans into **Mermaid graphs**.

Think of these diagrams as Pochi's whiteboard, where it sketches out its ideas for you to review. It's a communication tool designed to turn a complex plan into a simple, visual conversation. This allows you to understand, approve, and guide Pochi's approach before it writes a single line of code.

## A Visual Conversation for Complex Tasks

Pochi automatically generates Mermaid graphs when it needs to discuss its plan for complex tasks, such as:

* **Architectural Changes**: Showing how the overall structure of your application will be modified.
* **Complex Refactoring**: Breaking down a large function or class into smaller pieces.
* **New Feature Implementation**: Visualizing how a new feature will interact with existing components.

## Example: Pochi Proposes a Complex Refactor

When preparing for a significant refactoring, Pochi uses a diagram to discuss the proposed architecture with you. In this example, Pochi was asked to refactor a component for Server-Side Rendering (SSR). It first analyzed the code, then generated the following diagram to explain its findings and get your feedback.

![Tool Invocation Architecture](./images/tool-invocation-architecture.png)

This diagram provides a clear overview of the system, which was then used to formulate a refactoring plan. The analysis highlighted several key areas:

### Core Components:

* **ToolInvocationPart**: The main entry point that routes tools to the correct renderer.
* **Tools Registry**: A static mapping of tool names to their corresponding React components.
* **McpToolCall**: A specialized renderer for tools using the Model Context Protocol (MCP).
* **Shared UI Components**: A library of reusable components like containers, icons, and badges.

### SSR Challenges Identified:

The diagram helped identify three major challenges for implementing SSR:

1. **Client-Side State Dependencies**: Heavy reliance on React hooks (`useState`, `useCallback`) and context providers for managing the tool lifecycle, which are not available on the server.
2. **Browser/Environment Dependencies**: Components with direct dependencies on browser-specific features like `XTerm.js`, VS Code APIs, and file system interactions.
3. **Dynamic Component Resolution**: The architecture relies on a runtime tool registry and conditional rendering based on the tool's execution state, which is difficult to resolve on the server.

By visualizing the architecture, Pochi enabled the user to quickly understand the problem and approve the proposed strategy.

## Example: Pochi Clarifies Business Logic with a Flowchart

For changes to business logic, a code diff can be hard to follow. Pochi uses flowcharts to walk you through the new logic step-by-step. When asked to modify a task persistence feature, Pochi generated this flowchart to explain the new process.

![Task Persistence Flowchart](./images/persist-task-flow.png)

This visual explanation makes it much easier to verify the correctness of the new logic:

1. **Time Check**: The process starts with a throttling mechanism to prevent spamming the API.
2. **API Call**: If the check passes, it queries messages and calls the persistence API.
3. **Error Handling**: It includes a clear path for what happens if the API call fails.
4. **State Update**: It shows how the local state is updated with a `shareId` upon success.

This turns a code review into a collaborative check of the logic, ensuring you and Pochi are on the same page.

## Conclusion: Your Dialogue with Pochi

Mermaid graphs are more than just diagrams; they are the bridge for communication between you and Pochi. They transform a potential monologue of code into a clear, interactive dialogue about the best path forward.

When you see Pochi generate a Mermaid graph, it's an invitation to collaborate. Take a moment to review it‚Äîyour feedback is crucial for guiding the AI and ensuring the final result meets your exact expectations.

And remember, this is a two-way conversation. If you ever feel that Pochi's plan is unclear, you can proactively ask it to generate a Mermaid graph. Just say, "Can you explain that with a Mermaid diagram?" This puts you in control, allowing you to request visual clarity whenever you need it.
